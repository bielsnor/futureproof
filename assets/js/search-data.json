{
  
    
        "post0": {
            "title": "COVID19 Data Visualizations & Models by State",
            "content": "Main Datasets (w/ hospitalised data) . Source: https://covidtracking.com/ Source: https://github.com/CSSEGISandData/COVID-19 Various state data, third party data, and various federal data . Combine, validate, and verify data sets. . # see what filtered main dataframe looks like for all 50 states: all_cases.head(50) . date state positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently recovered dataQualityGrade ... totalTestsViral positiveTestsViral negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade . 0 2020-06-30 | AK | 940.0 | 400.0 | 18.0 | NaN | NaN | 1.0 | 526.0 | A | ... | 112185.0 | NaN | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | . 1 2020-06-30 | AL | 38045.0 | 18229.0 | 776.0 | 2769.0 | NaN | NaN | 18866.0 | B | ... | NaN | NaN | NaN | 37536.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 2 2020-06-30 | AR | 20777.0 | 5976.0 | 290.0 | 1413.0 | NaN | 67.0 | 14531.0 | A | ... | NaN | NaN | NaN | 20777.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 4 2020-06-30 | AZ | 79215.0 | 68172.0 | 2793.0 | 4736.0 | 683.0 | 455.0 | 9411.0 | A+ | ... | 531922.0 | NaN | NaN | 78781.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 5 2020-06-30 | CA | 222917.0 | NaN | 6466.0 | NaN | 1751.0 | NaN | NaN | B | ... | 4167139.0 | NaN | NaN | 222917.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 6 2020-06-30 | CO | 32511.0 | 26350.0 | 271.0 | 5442.0 | NaN | NaN | 4479.0 | A | ... | NaN | NaN | NaN | 29651.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 7 2020-06-30 | CT | 46514.0 | 34139.0 | 98.0 | 10268.0 | NaN | NaN | 8053.0 | B | ... | 464414.0 | NaN | NaN | 44534.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 8 2020-06-30 | DC | 10327.0 | 8506.0 | 126.0 | NaN | 33.0 | 22.0 | 1270.0 | A+ | ... | NaN | NaN | NaN | 10327.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 9 2020-06-30 | DE | 11474.0 | 4298.0 | 64.0 | NaN | 13.0 | NaN | 6667.0 | A+ | ... | NaN | NaN | NaN | 10430.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 10 2020-06-30 | FL | 152434.0 | NaN | NaN | 14879.0 | NaN | NaN | NaN | A | ... | 2337165.0 | 195894.0 | 2136944.0 | 152434.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 11 2020-06-30 | GA | 81291.0 | NaN | 1459.0 | 11051.0 | NaN | NaN | NaN | A | ... | 833878.0 | 74214.0 | 759664.0 | 81291.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 13 2020-06-30 | HI | 900.0 | 160.0 | NaN | 111.0 | NaN | NaN | 722.0 | D | ... | 90577.0 | 900.0 | 89677.0 | 900.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 14 2020-06-30 | IA | 29007.0 | 5080.0 | 133.0 | NaN | 34.0 | 20.0 | 23212.0 | A+ | ... | NaN | NaN | NaN | 29007.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 15 2020-06-30 | ID | 5752.0 | 1588.0 | NaN | 322.0 | NaN | NaN | 4073.0 | A | ... | 88763.0 | NaN | NaN | 5212.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 16 2020-06-30 | IL | 144238.0 | NaN | 1560.0 | NaN | 401.0 | 185.0 | NaN | A | ... | 1602965.0 | NaN | NaN | 143185.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 17 2020-06-30 | IN | 45594.0 | 8308.0 | 695.0 | 7065.0 | 272.0 | 97.0 | 34646.0 | A+ | ... | NaN | NaN | NaN | 45594.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 18 2020-06-30 | KS | 14443.0 | 13379.0 | NaN | 1152.0 | NaN | NaN | 794.0 | A | ... | NaN | NaN | NaN | 14443.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 19 2020-06-30 | KY | 15624.0 | 11069.0 | 408.0 | 2621.0 | 75.0 | NaN | 3990.0 | B | ... | NaN | NaN | NaN | 15090.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 20 2020-06-30 | LA | 58095.0 | 12649.0 | 781.0 | NaN | NaN | 83.0 | 42225.0 | B | ... | NaN | NaN | NaN | 58095.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 21 2020-06-30 | MA | 108882.0 | NaN | 733.0 | 11337.0 | 120.0 | 63.0 | NaN | A+ | ... | 1066060.0 | NaN | NaN | 103701.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 22 2020-06-30 | MD | 67559.0 | 59387.0 | 452.0 | 10844.0 | 152.0 | NaN | 4982.0 | A | ... | 652701.0 | NaN | NaN | 67559.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 23 2020-06-30 | ME | 3253.0 | 502.0 | 29.0 | 348.0 | 9.0 | 4.0 | 2646.0 | A | ... | 94592.0 | 3924.0 | 90532.0 | 2893.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 24 2020-06-30 | MI | 70728.0 | 13436.0 | 471.0 | NaN | 179.0 | 98.0 | 51099.0 | A+ | ... | 1062116.0 | 87787.0 | 974329.0 | 63870.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 25 2020-06-30 | MN | 36303.0 | 3226.0 | 270.0 | 4054.0 | 136.0 | NaN | 31601.0 | A | ... | 605316.0 | NaN | NaN | 36303.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 26 2020-06-30 | MO | 21551.0 | NaN | 599.0 | NaN | NaN | 66.0 | NaN | B | ... | 424214.0 | 23527.0 | 399926.0 | 21551.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 28 2020-06-30 | MS | 27247.0 | 6786.0 | 779.0 | 3156.0 | 167.0 | 91.0 | 19388.0 | A | ... | 299511.0 | NaN | NaN | 27067.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 29 2020-06-30 | MT | 967.0 | 303.0 | 12.0 | 101.0 | NaN | NaN | 642.0 | C | ... | NaN | NaN | NaN | 967.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 30 2020-06-30 | NC | 64670.0 | 17789.0 | 908.0 | NaN | NaN | NaN | 45538.0 | A | ... | NaN | NaN | NaN | 64670.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 31 2020-06-30 | ND | 3576.0 | 293.0 | 25.0 | 231.0 | NaN | NaN | 3195.0 | D | ... | 182283.0 | NaN | NaN | 3576.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 32 2020-06-30 | NE | 19042.0 | 5226.0 | 121.0 | 1330.0 | NaN | NaN | 13547.0 | B | ... | NaN | NaN | NaN | 19042.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 33 2020-06-30 | NH | 5760.0 | 958.0 | 34.0 | 565.0 | NaN | NaN | 4435.0 | B | ... | NaN | NaN | NaN | 5760.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 34 2020-06-30 | NJ | 171667.0 | 126419.0 | 992.0 | 19847.0 | 211.0 | 174.0 | 30213.0 | A+ | ... | NaN | NaN | NaN | 171667.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 35 2020-06-30 | NM | 11982.0 | 6193.0 | 119.0 | 1876.0 | NaN | NaN | 5296.0 | B | ... | NaN | NaN | NaN | 11982.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 36 2020-06-30 | NV | 18456.0 | 17260.0 | 593.0 | NaN | 134.0 | 65.0 | 689.0 | A+ | ... | 322944.0 | NaN | NaN | 18456.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 37 2020-06-30 | NY | 393454.0 | 298112.0 | 891.0 | 89995.0 | 217.0 | 137.0 | 70487.0 | A | ... | NaN | NaN | NaN | 393454.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 38 2020-06-30 | OH | 51789.0 | NaN | 722.0 | 7839.0 | 242.0 | 115.0 | NaN | B | ... | NaN | NaN | NaN | 48222.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 39 2020-06-30 | OK | 13757.0 | 3285.0 | 315.0 | 1520.0 | 111.0 | NaN | 10085.0 | A+ | ... | 343623.0 | 15029.0 | 327840.0 | 13757.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 40 2020-06-30 | OR | 8656.0 | 5727.0 | 149.0 | 1038.0 | 42.0 | 25.0 | 2722.0 | A+ | ... | NaN | NaN | 228978.0 | 8265.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 41 2020-06-30 | PA | 86606.0 | 12405.0 | 634.0 | NaN | NaN | 110.0 | 67552.0 | A+ | ... | NaN | NaN | NaN | 84130.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 43 2020-06-30 | RI | 16813.0 | 14232.0 | 74.0 | 2001.0 | 13.0 | 13.0 | 1631.0 | A+ | ... | NaN | NaN | NaN | 16813.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 44 2020-06-30 | SC | 36399.0 | 20189.0 | 1021.0 | 2854.0 | NaN | NaN | 15471.0 | A | ... | 380470.0 | 46401.0 | 334069.0 | 36297.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 45 2020-06-30 | SD | 6764.0 | 801.0 | 62.0 | 666.0 | NaN | NaN | 5872.0 | B | ... | NaN | NaN | NaN | 6764.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 46 2020-06-30 | TN | 43509.0 | 15306.0 | 527.0 | 2665.0 | NaN | NaN | 27599.0 | B | ... | 792779.0 | 50413.0 | 742366.0 | 43161.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 47 2020-06-30 | TX | 159986.0 | 72744.0 | 6533.0 | NaN | NaN | NaN | 84818.0 | B | ... | 1869282.0 | NaN | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | . 48 2020-06-30 | UT | 22217.0 | 9647.0 | 250.0 | 1444.0 | 83.0 | NaN | 12398.0 | A+ | ... | NaN | NaN | NaN | 22217.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 49 2020-06-30 | VA | 62787.0 | 52944.0 | 902.0 | 8982.0 | 230.0 | 98.0 | 8080.0 | A+ | ... | 642371.0 | NaN | NaN | 60124.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 51 2020-06-30 | VT | 1208.0 | 199.0 | 16.0 | NaN | NaN | NaN | 953.0 | B | ... | NaN | NaN | NaN | 1208.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 52 2020-06-30 | WA | 32253.0 | NaN | 282.0 | 4323.0 | NaN | 50.0 | NaN | B | ... | NaN | NaN | NaN | 32253.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 53 2020-06-30 | WI | 31662.0 | 8291.0 | 242.0 | 3446.0 | 79.0 | NaN | 22587.0 | A+ | ... | NaN | NaN | NaN | 28659.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 54 2020-06-30 | WV | 2905.0 | 540.0 | 27.0 | NaN | 10.0 | 3.0 | 2272.0 | B | ... | NaN | NaN | NaN | 2804.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 50 rows × 25 columns . #Add state level data, beds, beds/1k, population, abbreviation, and name: all_cases.head(50) . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-30 | Alaska | AK | 734002 | 940.0 | 400.0 | 18.0 | NaN | NaN | 1.0 | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 2.2 | 1614.8044 | . 1 2020-06-30 | Alabama | AL | 4908621 | 38045.0 | 18229.0 | 776.0 | 2769.0 | NaN | NaN | ... | NaN | 37536.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.1 | 15216.7251 | . 2 2020-06-30 | Arkansas | AR | 3038999 | 20777.0 | 5976.0 | 290.0 | 1413.0 | NaN | 67.0 | ... | NaN | 20777.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.2 | 9724.7968 | . 3 2020-06-30 | Arizona | AZ | 7378494 | 79215.0 | 68172.0 | 2793.0 | 4736.0 | 683.0 | 455.0 | ... | NaN | 78781.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 14019.1386 | . 4 2020-06-30 | California | CA | 39937489 | 222917.0 | NaN | 6466.0 | NaN | 1751.0 | NaN | ... | NaN | 222917.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.8 | 71887.4802 | . 5 2020-06-30 | Colorado | CO | 5845526 | 32511.0 | 26350.0 | 271.0 | 5442.0 | NaN | NaN | ... | NaN | 29651.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 11106.4994 | . 6 2020-06-30 | Connecticut | CT | 3563077 | 46514.0 | 34139.0 | 98.0 | 10268.0 | NaN | NaN | ... | NaN | 44534.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.0 | 7126.1540 | . 7 2020-06-30 | District of Columbia | DC | 720687 | 10327.0 | 8506.0 | 126.0 | NaN | 33.0 | 22.0 | ... | NaN | 10327.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.4 | 3171.0228 | . 8 2020-06-30 | Delaware | DE | 982895 | 11474.0 | 4298.0 | 64.0 | NaN | 13.0 | NaN | ... | NaN | 10430.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.2 | 2162.3690 | . 9 2020-06-30 | Florida | FL | 21992985 | 152434.0 | NaN | NaN | 14879.0 | NaN | NaN | ... | 2136944.0 | 152434.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.6 | 57181.7610 | . 10 2020-06-30 | Georgia | GA | 10736059 | 81291.0 | NaN | 1459.0 | 11051.0 | NaN | NaN | ... | 759664.0 | 81291.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.4 | 25766.5416 | . 11 2020-06-30 | Hawaii | HI | 1412687 | 900.0 | 160.0 | NaN | 111.0 | NaN | NaN | ... | 89677.0 | 900.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 2684.1053 | . 12 2020-06-30 | Iowa | IA | 3179849 | 29007.0 | 5080.0 | 133.0 | NaN | 34.0 | 20.0 | ... | NaN | 29007.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.0 | 9539.5470 | . 13 2020-06-30 | Idaho | ID | 1826156 | 5752.0 | 1588.0 | NaN | 322.0 | NaN | NaN | ... | NaN | 5212.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 3469.6964 | . 14 2020-06-30 | Illinois | IL | 12659682 | 144238.0 | NaN | 1560.0 | NaN | 401.0 | 185.0 | ... | NaN | 143185.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 31649.2050 | . 15 2020-06-30 | Indiana | IN | 6745354 | 45594.0 | 8308.0 | 695.0 | 7065.0 | 272.0 | 97.0 | ... | NaN | 45594.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.7 | 18212.4558 | . 16 2020-06-30 | Kansas | KS | 2910357 | 14443.0 | 13379.0 | NaN | 1152.0 | NaN | NaN | ... | NaN | 14443.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 9604.1781 | . 17 2020-06-30 | Kentucky | KY | 4499692 | 15624.0 | 11069.0 | 408.0 | 2621.0 | 75.0 | NaN | ... | NaN | 15090.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.2 | 14399.0144 | . 18 2020-06-30 | Louisiana | LA | 4645184 | 58095.0 | 12649.0 | 781.0 | NaN | NaN | 83.0 | ... | NaN | 58095.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 15329.1072 | . 19 2020-06-30 | Massachusetts | MA | 6976597 | 108882.0 | NaN | 733.0 | 11337.0 | 120.0 | 63.0 | ... | NaN | 103701.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.3 | 16046.1731 | . 20 2020-06-30 | Maryland | MD | 6083116 | 67559.0 | 59387.0 | 452.0 | 10844.0 | 152.0 | NaN | ... | NaN | 67559.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 11557.9204 | . 21 2020-06-30 | Maine | ME | 1345790 | 3253.0 | 502.0 | 29.0 | 348.0 | 9.0 | 4.0 | ... | 90532.0 | 2893.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 3364.4750 | . 22 2020-06-30 | Michigan | MI | 10045029 | 70728.0 | 13436.0 | 471.0 | NaN | 179.0 | 98.0 | ... | 974329.0 | 63870.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 25112.5725 | . 23 2020-06-30 | Minnesota | MN | 5700671 | 36303.0 | 3226.0 | 270.0 | 4054.0 | 136.0 | NaN | ... | NaN | 36303.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 14251.6775 | . 24 2020-06-30 | Missouri | MO | 6169270 | 21551.0 | NaN | 599.0 | NaN | NaN | 66.0 | ... | 399926.0 | 21551.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.1 | 19124.7370 | . 25 2020-06-30 | Mississippi | MS | 2989260 | 27247.0 | 6786.0 | 779.0 | 3156.0 | 167.0 | 91.0 | ... | NaN | 27067.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.0 | 11957.0400 | . 26 2020-06-30 | Montana | MT | 1086759 | 967.0 | 303.0 | 12.0 | 101.0 | NaN | NaN | ... | NaN | 967.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 3586.3047 | . 27 2020-06-30 | North Carolina | NC | 10611862 | 64670.0 | 17789.0 | 908.0 | NaN | NaN | NaN | ... | NaN | 64670.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.1 | 22284.9102 | . 28 2020-06-30 | North Dakota | ND | 761723 | 3576.0 | 293.0 | 25.0 | 231.0 | NaN | NaN | ... | NaN | 3576.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.3 | 3275.4089 | . 29 2020-06-30 | Nebraska | NE | 1952570 | 19042.0 | 5226.0 | 121.0 | 1330.0 | NaN | NaN | ... | NaN | 19042.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.6 | 7029.2520 | . 30 2020-06-30 | New Hampshire | NH | 1371246 | 5760.0 | 958.0 | 34.0 | 565.0 | NaN | NaN | ... | NaN | 5760.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.1 | 2879.6166 | . 31 2020-06-30 | New Jersey | NJ | 8936574 | 171667.0 | 126419.0 | 992.0 | 19847.0 | 211.0 | 174.0 | ... | NaN | 171667.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.4 | 21447.7776 | . 32 2020-06-30 | New Mexico | NM | 2096640 | 11982.0 | 6193.0 | 119.0 | 1876.0 | NaN | NaN | ... | NaN | 11982.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.8 | 3773.9520 | . 33 2020-06-30 | Nevada | NV | 3139658 | 18456.0 | 17260.0 | 593.0 | NaN | 134.0 | 65.0 | ... | NaN | 18456.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.1 | 6593.2818 | . 34 2020-06-30 | New York | NY | 19440469 | 393454.0 | 298112.0 | 891.0 | 89995.0 | 217.0 | 137.0 | ... | NaN | 393454.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.7 | 52489.2663 | . 35 2020-06-30 | Ohio | OH | 11747694 | 51789.0 | NaN | 722.0 | 7839.0 | 242.0 | 115.0 | ... | NaN | 48222.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.8 | 32893.5432 | . 36 2020-06-30 | Oklahoma | OK | 3954821 | 13757.0 | 3285.0 | 315.0 | 1520.0 | 111.0 | NaN | ... | 327840.0 | 13757.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.8 | 11073.4988 | . 37 2020-06-30 | Oregon | OR | 4301089 | 8656.0 | 5727.0 | 149.0 | 1038.0 | 42.0 | 25.0 | ... | 228978.0 | 8265.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.6 | 6881.7424 | . 38 2020-06-30 | Pennsylvania | PA | 12820878 | 86606.0 | 12405.0 | 634.0 | NaN | NaN | 110.0 | ... | NaN | 84130.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.9 | 37180.5462 | . 39 2020-06-30 | Rhode Island | RI | 1056161 | 16813.0 | 14232.0 | 74.0 | 2001.0 | 13.0 | 13.0 | ... | NaN | 16813.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.1 | 2217.9381 | . 40 2020-06-30 | South Carolina | SC | 5210095 | 36399.0 | 20189.0 | 1021.0 | 2854.0 | NaN | NaN | ... | 334069.0 | 36297.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.4 | 12504.2280 | . 41 2020-06-30 | South Dakota | SD | 903027 | 6764.0 | 801.0 | 62.0 | 666.0 | NaN | NaN | ... | NaN | 6764.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.8 | 4334.5296 | . 42 2020-06-30 | Tennessee | TN | 6897576 | 43509.0 | 15306.0 | 527.0 | 2665.0 | NaN | NaN | ... | 742366.0 | 43161.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.9 | 20002.9704 | . 43 2020-06-30 | Texas | TX | 29472295 | 159986.0 | 72744.0 | 6533.0 | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 2.3 | 67786.2785 | . 44 2020-06-30 | Utah | UT | 3282115 | 22217.0 | 9647.0 | 250.0 | 1444.0 | 83.0 | NaN | ... | NaN | 22217.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.8 | 5907.8070 | . 45 2020-06-30 | Virginia | VA | 8626207 | 62787.0 | 52944.0 | 902.0 | 8982.0 | 230.0 | 98.0 | ... | NaN | 60124.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.1 | 18115.0347 | . 46 2020-06-30 | Vermont | VT | 628061 | 1208.0 | 199.0 | 16.0 | NaN | NaN | NaN | ... | NaN | 1208.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.1 | 1318.9281 | . 47 2020-06-30 | Washington | WA | 7797095 | 32253.0 | NaN | 282.0 | 4323.0 | NaN | 50.0 | ... | NaN | 32253.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 48 2020-06-30 | Wisconsin | WI | 5851754 | 31662.0 | 8291.0 | 242.0 | 3446.0 | 79.0 | NaN | ... | NaN | 28659.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.1 | 12288.6834 | . 49 2020-06-30 | West Virginia | WV | 1778070 | 2905.0 | 540.0 | 27.0 | NaN | 10.0 | 3.0 | ... | NaN | 2804.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.8 | 6756.6660 | . 50 rows × 29 columns . Load and clean JHU data | Merge JHU dataset with main dataset | . #Load the Johns Hopkins data jhu_df.tail(50) . LastUpdate ProvinceState Active Confirmed Deaths Recovered . 5145 2020-06-19 | Alaska | 695.0 | 707.0 | 12.0 | 0.0 | . 5146 2020-06-19 | Arizona | 42162.0 | 43445.0 | 1283.0 | 0.0 | . 5147 2020-06-19 | Arkansas | 13720.0 | 13928.0 | 208.0 | 0.0 | . 5148 2020-06-19 | California | 161731.0 | 167086.0 | 5355.0 | 0.0 | . 5149 2020-06-19 | Colorado | 28248.0 | 29886.0 | 1638.0 | 0.0 | . 5150 2020-06-19 | Connecticut | 41214.0 | 45440.0 | 4226.0 | 0.0 | . 5151 2020-06-19 | Delaware | 10068.0 | 10499.0 | 431.0 | 0.0 | . 5152 2020-06-19 | District of Columbia | 9376.0 | 9903.0 | 527.0 | 0.0 | . 5153 2020-06-19 | Florida | 82865.0 | 85926.0 | 3061.0 | 0.0 | . 5154 2020-06-19 | Georgia | 58307.0 | 60912.0 | 2605.0 | 0.0 | . 5155 2020-06-19 | Hawaii | 745.0 | 762.0 | 17.0 | 0.0 | . 5156 2020-06-19 | Idaho | 3654.0 | 3743.0 | 89.0 | 0.0 | . 5157 2020-06-19 | Illinois | 128241.0 | 134778.0 | 6537.0 | 0.0 | . 5158 2020-06-19 | Indiana | 38947.0 | 41438.0 | 2491.0 | 0.0 | . 5159 2020-06-19 | Iowa | 24181.0 | 24861.0 | 680.0 | 0.0 | . 5160 2020-06-19 | Kansas | 11502.0 | 11753.0 | 251.0 | 0.0 | . 5161 2020-06-19 | Kentucky | 12677.0 | 13197.0 | 520.0 | 0.0 | . 5162 2020-06-19 | Louisiana | 45572.0 | 48634.0 | 3062.0 | 0.0 | . 5163 2020-06-19 | Maine | 2776.0 | 2878.0 | 102.0 | 0.0 | . 5164 2020-06-19 | Maryland | 60213.0 | 63229.0 | 3016.0 | 0.0 | . 5165 2020-06-19 | Massachusetts | 98653.0 | 106422.0 | 7769.0 | 0.0 | . 5166 2020-06-19 | Michigan | 60737.0 | 66798.0 | 6061.0 | 0.0 | . 5167 2020-06-19 | Minnesota | 30299.0 | 31675.0 | 1376.0 | 0.0 | . 5168 2020-06-19 | Mississippi | 19703.0 | 20641.0 | 938.0 | 0.0 | . 5169 2020-06-19 | Missouri | 16426.0 | 17371.0 | 945.0 | 0.0 | . 5170 2020-06-19 | Montana | 635.0 | 655.0 | 20.0 | 0.0 | . 5171 2020-06-19 | Nebraska | 17175.0 | 17414.0 | 239.0 | 0.0 | . 5172 2020-06-19 | Nevada | 11694.0 | 12169.0 | 475.0 | 0.0 | . 5173 2020-06-19 | New Hampshire | 5119.0 | 5450.0 | 331.0 | 0.0 | . 5174 2020-06-19 | New Jersey | 155238.0 | 168107.0 | 12869.0 | 0.0 | . 5175 2020-06-19 | New Mexico | 9697.0 | 10153.0 | 456.0 | 0.0 | . 5176 2020-06-19 | New York | 354786.0 | 385760.0 | 30974.0 | 0.0 | . 5177 2020-06-19 | North Carolina | 46972.0 | 48168.0 | 1196.0 | 0.0 | . 5178 2020-06-19 | North Dakota | 3118.0 | 3193.0 | 75.0 | 0.0 | . 5179 2020-06-19 | Ohio | 40489.0 | 43122.0 | 2633.0 | 0.0 | . 5180 2020-06-19 | Oklahoma | 8989.0 | 9355.0 | 366.0 | 0.0 | . 5181 2020-06-19 | Oregon | 6179.0 | 6366.0 | 187.0 | 0.0 | . 5182 2020-06-19 | Pennsylvania | 78322.0 | 84683.0 | 6361.0 | 0.0 | . 5183 2020-06-19 | Rhode Island | 15384.0 | 16269.0 | 885.0 | 0.0 | . 5184 2020-06-19 | South Carolina | 20912.0 | 21533.0 | 621.0 | 0.0 | . 5185 2020-06-19 | South Dakota | 6031.0 | 6109.0 | 78.0 | 0.0 | . 5186 2020-06-19 | Tennessee | 32262.0 | 32770.0 | 508.0 | 0.0 | . 5187 2020-06-19 | Texas | 99130.0 | 101259.0 | 2129.0 | 0.0 | . 5188 2020-06-19 | Utah | 15687.0 | 15839.0 | 152.0 | 0.0 | . 5189 2020-06-19 | Vermont | 1079.0 | 1135.0 | 56.0 | 0.0 | . 5190 2020-06-19 | Virginia | 54652.0 | 56238.0 | 1586.0 | 0.0 | . 5191 2020-06-19 | Washington | 25947.0 | 27192.0 | 1245.0 | 0.0 | . 5192 2020-06-19 | West Virginia | 2330.0 | 2418.0 | 88.0 | 0.0 | . 5193 2020-06-19 | Wisconsin | 23157.0 | 23876.0 | 719.0 | 0.0 | . 5194 2020-06-19 | Wyoming | 1126.0 | 1144.0 | 18.0 | 0.0 | . #Grab all historical data and ensure we have the 1st US case. all_cases.tail() . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 6029 2020-01-26 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 6030 2020-01-25 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 6031 2020-01-24 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 6032 2020-01-23 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 6033 2020-01-22 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5 rows × 29 columns . An Exploratory data analysis of the US dataset. . Validate data types and data integrity of each row. . #We check the data type are correct above and review our combined, cleaned, validated, and merged data set for all 50 states: covid_df.head(50) . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-30 | Alaska | AK | 734002 | 940.000 | 400.000 | 18.000 | nan | nan | 1.000 | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 2.200 | 1614.804 | . 1 2020-06-30 | Alabama | AL | 4908621 | 38045.000 | 18229.000 | 776.000 | 2769.000 | nan | nan | ... | nan | 37536.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.100 | 15216.725 | . 2 2020-06-30 | Arkansas | AR | 3038999 | 20777.000 | 5976.000 | 290.000 | 1413.000 | nan | 67.000 | ... | nan | 20777.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.200 | 9724.797 | . 3 2020-06-30 | Arizona | AZ | 7378494 | 79215.000 | 68172.000 | 2793.000 | 4736.000 | 683.000 | 455.000 | ... | nan | 78781.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 14019.139 | . 4 2020-06-30 | California | CA | 39937489 | 222917.000 | 216937.000 | 6466.000 | nan | 1751.000 | nan | ... | nan | 222917.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.800 | 71887.480 | . 5 2020-06-30 | Colorado | CO | 5845526 | 32511.000 | 26350.000 | 271.000 | 5442.000 | nan | nan | ... | nan | 29651.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 11106.499 | . 6 2020-06-30 | Connecticut | CT | 3563077 | 46514.000 | 34139.000 | 98.000 | 10268.000 | nan | nan | ... | nan | 44534.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.000 | 7126.154 | . 7 2020-06-30 | District of Columbia | DC | 720687 | 10327.000 | 8506.000 | 126.000 | nan | 33.000 | 22.000 | ... | nan | 10327.000 | 0 | 0 | 0 | 0 | 0 | nan | 4.400 | 3171.023 | . 8 2020-06-30 | Delaware | DE | 982895 | 11474.000 | 4298.000 | 64.000 | nan | 13.000 | nan | ... | nan | 10430.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.200 | 2162.369 | . 9 2020-06-30 | Florida | FL | 21992985 | 152434.000 | 148830.000 | nan | 14879.000 | nan | nan | ... | 2136944.000 | 152434.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.600 | 57181.761 | . 10 2020-06-30 | Georgia | GA | 10736059 | 81291.000 | 78486.000 | 1459.000 | 11051.000 | nan | nan | ... | 759664.000 | 81291.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.400 | 25766.542 | . 11 2020-06-30 | Hawaii | HI | 1412687 | 900.000 | 160.000 | nan | 111.000 | nan | nan | ... | 89677.000 | 900.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 2684.105 | . 12 2020-06-30 | Iowa | IA | 3179849 | 29007.000 | 5080.000 | 133.000 | nan | 34.000 | 20.000 | ... | nan | 29007.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.000 | 9539.547 | . 13 2020-06-30 | Idaho | ID | 1826156 | 5752.000 | 1588.000 | nan | 322.000 | nan | nan | ... | nan | 5212.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 3469.696 | . 14 2020-06-30 | Illinois | IL | 12659682 | 144238.000 | 137114.000 | 1560.000 | nan | 401.000 | 185.000 | ... | nan | 143185.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.500 | 31649.205 | . 15 2020-06-30 | Indiana | IN | 6745354 | 45594.000 | 8308.000 | 695.000 | 7065.000 | 272.000 | 97.000 | ... | nan | 45594.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.700 | 18212.456 | . 16 2020-06-30 | Kansas | KS | 2910357 | 14443.000 | 13379.000 | nan | 1152.000 | nan | nan | ... | nan | 14443.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.300 | 9604.178 | . 17 2020-06-30 | Kentucky | KY | 4499692 | 15624.000 | 11069.000 | 408.000 | 2621.000 | 75.000 | nan | ... | nan | 15090.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.200 | 14399.014 | . 18 2020-06-30 | Louisiana | LA | 4645184 | 58095.000 | 12649.000 | 781.000 | nan | nan | 83.000 | ... | nan | 58095.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.300 | 15329.107 | . 19 2020-06-30 | Massachusetts | MA | 6976597 | 108882.000 | 100828.000 | 733.000 | 11337.000 | 120.000 | 63.000 | ... | nan | 103701.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.300 | 16046.173 | . 20 2020-06-30 | Maryland | MD | 6083116 | 67559.000 | 59387.000 | 452.000 | 10844.000 | 152.000 | nan | ... | nan | 67559.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 11557.920 | . 21 2020-06-30 | Maine | ME | 1345790 | 3253.000 | 502.000 | 29.000 | 348.000 | 9.000 | 4.000 | ... | 90532.000 | 2893.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.500 | 3364.475 | . 22 2020-06-30 | Michigan | MI | 10045029 | 70728.000 | 13436.000 | 471.000 | nan | 179.000 | 98.000 | ... | 974329.000 | 63870.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.500 | 25112.572 | . 23 2020-06-30 | Minnesota | MN | 5700671 | 36303.000 | 3226.000 | 270.000 | 4054.000 | 136.000 | nan | ... | nan | 36303.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.500 | 14251.678 | . 24 2020-06-30 | Missouri | MO | 6169270 | 21551.000 | 20536.000 | 599.000 | nan | nan | 66.000 | ... | 399926.000 | 21551.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.100 | 19124.737 | . 25 2020-06-30 | Mississippi | MS | 2989260 | 27247.000 | 6786.000 | 779.000 | 3156.000 | 167.000 | 91.000 | ... | nan | 27067.000 | 0 | 0 | 0 | 0 | 0 | nan | 4.000 | 11957.040 | . 26 2020-06-30 | Montana | MT | 1086759 | 967.000 | 303.000 | 12.000 | 101.000 | nan | nan | ... | nan | 967.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.300 | 3586.305 | . 27 2020-06-30 | North Carolina | NC | 10611862 | 64670.000 | 17789.000 | 908.000 | nan | nan | nan | ... | nan | 64670.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.100 | 22284.910 | . 28 2020-06-30 | North Dakota | ND | 761723 | 3576.000 | 293.000 | 25.000 | 231.000 | nan | nan | ... | nan | 3576.000 | 0 | 0 | 0 | 0 | 0 | nan | 4.300 | 3275.409 | . 29 2020-06-30 | Nebraska | NE | 1952570 | 19042.000 | 5226.000 | 121.000 | 1330.000 | nan | nan | ... | nan | 19042.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.600 | 7029.252 | . 30 2020-06-30 | New Hampshire | NH | 1371246 | 5760.000 | 958.000 | 34.000 | 565.000 | nan | nan | ... | nan | 5760.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.100 | 2879.617 | . 31 2020-06-30 | New Jersey | NJ | 8936574 | 171667.000 | 126419.000 | 992.000 | 19847.000 | 211.000 | 174.000 | ... | nan | 171667.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.400 | 21447.778 | . 32 2020-06-30 | New Mexico | NM | 2096640 | 11982.000 | 6193.000 | 119.000 | 1876.000 | nan | nan | ... | nan | 11982.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.800 | 3773.952 | . 33 2020-06-30 | Nevada | NV | 3139658 | 18456.000 | 17260.000 | 593.000 | nan | 134.000 | 65.000 | ... | nan | 18456.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.100 | 6593.282 | . 34 2020-06-30 | New York | NY | 19440469 | 393454.000 | 298112.000 | 891.000 | 89995.000 | 217.000 | 137.000 | ... | nan | 393454.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.700 | 52489.266 | . 35 2020-06-30 | Ohio | OH | 11747694 | 51789.000 | 48926.000 | 722.000 | 7839.000 | 242.000 | 115.000 | ... | nan | 48222.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.800 | 32893.543 | . 36 2020-06-30 | Oklahoma | OK | 3954821 | 13757.000 | 3285.000 | 315.000 | 1520.000 | 111.000 | nan | ... | 327840.000 | 13757.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.800 | 11073.499 | . 37 2020-06-30 | Oregon | OR | 4301089 | 8656.000 | 5727.000 | 149.000 | 1038.000 | 42.000 | 25.000 | ... | 228978.000 | 8265.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.600 | 6881.742 | . 38 2020-06-30 | Pennsylvania | PA | 12820878 | 86606.000 | 12405.000 | 634.000 | nan | nan | 110.000 | ... | nan | 84130.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.900 | 37180.546 | . 39 2020-06-30 | Rhode Island | RI | 1056161 | 16813.000 | 14232.000 | 74.000 | 2001.000 | 13.000 | 13.000 | ... | nan | 16813.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.100 | 2217.938 | . 40 2020-06-30 | South Carolina | SC | 5210095 | 36399.000 | 20189.000 | 1021.000 | 2854.000 | nan | nan | ... | 334069.000 | 36297.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.400 | 12504.228 | . 41 2020-06-30 | South Dakota | SD | 903027 | 6764.000 | 801.000 | 62.000 | 666.000 | nan | nan | ... | nan | 6764.000 | 0 | 0 | 0 | 0 | 0 | nan | 4.800 | 4334.530 | . 42 2020-06-30 | Tennessee | TN | 6897576 | 43509.000 | 15306.000 | 527.000 | 2665.000 | nan | nan | ... | 742366.000 | 43161.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.900 | 20002.970 | . 43 2020-06-30 | Texas | TX | 29472295 | 159986.000 | 72744.000 | 6533.000 | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 2.300 | 67786.278 | . 44 2020-06-30 | Utah | UT | 3282115 | 22217.000 | 9647.000 | 250.000 | 1444.000 | 83.000 | nan | ... | nan | 22217.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.800 | 5907.807 | . 45 2020-06-30 | Virginia | VA | 8626207 | 62787.000 | 52944.000 | 902.000 | 8982.000 | 230.000 | 98.000 | ... | nan | 60124.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.100 | 18115.035 | . 46 2020-06-30 | Vermont | VT | 628061 | 1208.000 | 199.000 | 16.000 | nan | nan | nan | ... | nan | 1208.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.100 | 1318.928 | . 47 2020-06-30 | Washington | WA | 7797095 | 32253.000 | 30933.000 | 282.000 | 4323.000 | nan | 50.000 | ... | nan | 32253.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 48 2020-06-30 | Wisconsin | WI | 5851754 | 31662.000 | 8291.000 | 242.000 | 3446.000 | 79.000 | nan | ... | nan | 28659.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.100 | 12288.683 | . 49 2020-06-30 | West Virginia | WV | 1778070 | 2905.000 | 540.000 | 27.000 | nan | 10.000 | 3.000 | ... | nan | 2804.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.800 | 6756.666 | . 50 rows × 29 columns . The NaN values may indicate that there were no to few Covid-19 patients at these date points. We further analyse the statistical values of the dataset columns to ensure data integrity and accuracy. . #Validte the data with; mean, standard deviation, min/max quartiles: covid_df.describe() # TODO rounding up the numbers . population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently recovered death hospitalized ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . count 6034.000 | 6034.000 | 6034.000 | 3739.000 | 3306.000 | 1933.000 | 1720.000 | 6034.000 | 6034.000 | 3306.000 | ... | 557.000 | 3206.000 | 6034.000 | 6034.000 | 6034.000 | 6034.000 | 6034.000 | 0.000 | 6034.000 | 6034.000 | . mean 6542177.949 | 21664.959 | 19012.828 | 1016.199 | 4420.804 | 435.195 | 221.276 | 4634.585 | 1122.867 | 4420.804 | ... | 304052.707 | 32743.682 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 2.626 | 15805.406 | . std 7386887.293 | 47418.576 | 42396.431 | 1914.007 | 12997.569 | 686.535 | 325.642 | 11309.159 | 2952.200 | 12997.569 | ... | 401425.780 | 57145.293 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 0.744 | 16159.400 | . min 567025.000 | 0.000 | 0.000 | 1.000 | 0.000 | 2.000 | 0.000 | 0.000 | 0.000 | 0.000 | ... | 17.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 1.600 | 1318.928 | . 25% 1778070.000 | 654.250 | 565.500 | 119.000 | 225.250 | 81.000 | 35.000 | 0.000 | 13.000 | 225.250 | ... | 50591.000 | 5129.750 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 2.100 | 3773.952 | . 50% 4499692.000 | 5309.000 | 4671.000 | 402.000 | 997.000 | 179.000 | 93.000 | 255.500 | 152.500 | 997.000 | ... | 148910.000 | 14087.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 2.500 | 11557.920 | . 75% 7797095.000 | 21609.000 | 17784.750 | 1009.500 | 3335.500 | 472.000 | 244.000 | 3252.000 | 806.750 | 3335.500 | ... | 399926.000 | 36296.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 3.100 | 19124.737 | . max 39937489.000 | 393454.000 | 356899.000 | 18825.000 | 89995.000 | 5225.000 | 2425.000 | 84818.000 | 24855.000 | 89995.000 | ... | 2136944.000 | 393454.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 4.800 | 71887.480 | . 8 rows × 22 columns . #final_100k_last_month.head() . #Review the out for per capita measures: final_100k_last_month.describe() . positive_100k active_100k recovered_100k death_100k hospitalizedCumulative_100k inIcuCurrently_100k onVentilatorCurrently_100k BedsPer100k . count 61.000 | 61.000 | 61.000 | 61.000 | 61.000 | 62.000 | 62.000 | 62.000 | . mean 358.759 | 336.008 | 170.212 | 17.931 | 34.329 | 113.658 | 62.620 | 13440.000 | . std 65.620 | 442.921 | 105.723 | 7.283 | 42.821 | 26.916 | 13.514 | 0.000 | . min 245.203 | -2213.482 | 35.481 | 4.880 | -93.926 | 70.613 | 39.353 | 13440.000 | . 25% 308.315 | 292.339 | 107.989 | 12.184 | 21.638 | 94.079 | 53.461 | 13440.000 | . 50% 344.558 | 332.717 | 147.227 | 17.253 | 25.122 | 111.563 | 62.120 | 13440.000 | . 75% 405.031 | 370.778 | 211.312 | 23.811 | 29.823 | 126.991 | 74.683 | 13440.000 | . max 544.349 | 2291.210 | 626.665 | 33.917 | 246.371 | 167.561 | 94.521 | 13440.000 | . Graphical Exploratory Analysis. . Plotting histograms, scatterplots and boxplots to assess the distribution of the entire US dataset. . #Validate all US data: timeseries_usa_df.tail() . date positive_100k active_100k recovered_100k death_100k hospitalizedCurrently_100k inIcuCurrently_100k onVentilatorCurrently_100k BedsPer100k . 156 2020-06-26 | 34335.924 | 20098.997 | 12643.998 | 1592.929 | 404.115 | 67.051 | 34.318 | 13440.000 | . 157 2020-06-27 | 34829.638 | 20417.559 | 12812.241 | 1599.839 | 407.257 | 68.533 | 35.118 | 13440.000 | . 158 2020-06-28 | 35334.565 | 20809.528 | 12921.408 | 1603.630 | 402.011 | 65.968 | 33.930 | 13440.000 | . 159 2020-06-29 | 35834.140 | 20955.190 | 13269.151 | 1609.799 | 409.624 | 66.395 | 32.901 | 13440.000 | . 160 2020-06-30 | 36369.224 | 21135.140 | 13616.885 | 1617.200 | 423.406 | 66.047 | 33.482 | 13440.000 | . Analysis of Hospitalizations by State. . Red data plots are Republican Governed States. Blue data plots are Democratic Governed States. . Alabama . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Arizona . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;% Positive Cases in Hospital&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Arkansas . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . California . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Colorado . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Connecticut . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Delaware . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Florida . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(fl.date, fl.positiveTestsViral, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Cummulative Number of Positive Viral Tests in Florida&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;% Infected&#39;) . Georgia . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;% Infection Rate&#39;) . Hawaii . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Text(0, 0.5, &#39;% Infected&#39;) . Idaho . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Iowa . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Kansas . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Kentucky . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Louisiana . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Maine . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Maryland . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Massachusetts . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Michigan . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Minnesota . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Mississippi . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Missouri . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Montana . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Nebraska . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Nevada: . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . New Hampshire . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . New Jersey . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . New Mexico . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . New York . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . North Carolina . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Ohio . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Oklahoma . Text(0, 0.5, &#39;No. Patients&#39;) . Oregon . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Pennsylvania . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Rhode Island . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . South Carolina . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;% Infection Rate&#39;) . South Dakota . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Tennessee . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Texas . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Utah . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Vermont . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Virginia . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Washington . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . West Virginia . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Wisconsin . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Wyoming . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Killed&#39;) . Assessing Correlation of Independent Variables. . &lt;matplotlib.axes._subplots.AxesSubplot at 0x21428e918c8&gt; . Build Model for Dependent Variables . To be used to predict future projections | . population positive active hospitalizedCurrently inIcuCurrently onVentilatorCurrently recovered death totalTestsViral positiveTestsViral negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade total_beds . count 3701.000 | 3701.000 | 3701.000 | 3701.000 | 1882.000 | 1672.000 | 3701.000 | 3701.000 | 1162.000 | 415.000 | 417.000 | 2621.000 | 3701.000 | 3701.000 | 3701.000 | 3701.000 | 3701.000 | 0.000 | 3701.000 | . mean 6717922.344 | 32357.466 | 28164.459 | 1012.444 | 431.738 | 218.293 | 7215.129 | 1736.273 | 415764.614 | 25876.993 | 251513.187 | 37022.470 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 15979.358 | . std 7708217.793 | 57218.993 | 51227.633 | 1917.786 | 692.148 | 327.900 | 13727.753 | 3621.711 | 562113.287 | 26405.211 | 238484.175 | 61581.576 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 16458.688 | . min 567025.000 | 115.000 | 113.000 | 1.000 | 2.000 | 0.000 | 0.000 | 0.000 | 9055.000 | 407.000 | 8648.000 | 396.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 1318.928 | . 25% 1778070.000 | 3361.000 | 2863.000 | 117.000 | 79.250 | 33.000 | 15.000 | 93.000 | 90620.000 | 4128.000 | 64555.000 | 6538.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 3773.952 | . 50% 4645184.000 | 12674.000 | 10131.000 | 398.000 | 174.500 | 91.000 | 1341.000 | 483.000 | 231934.000 | 14361.000 | 168871.000 | 16661.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 11557.920 | . 75% 7797095.000 | 36096.000 | 30074.000 | 998.000 | 451.250 | 236.250 | 6459.000 | 1617.000 | 509060.750 | 45496.000 | 327840.000 | 41249.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 19124.737 | . max 39937489.000 | 393454.000 | 356899.000 | 18825.000 | 5225.000 | 2425.000 | 84818.000 | 24855.000 | 4167139.000 | 87787.000 | 974329.000 | 393454.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 71887.480 | .",
            "url": "https://bielsnor.github.io/futureproof/futureproof-COVID19-States/",
            "relUrl": "/futureproof-COVID19-States/",
            "date": " • Jun 29, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Matplotlibtard",
            "content": "import numpy as np import matplotlib.pyplot as plt fig = plt.figure() x = np.arange(10) y = 2.5 * np.sin(x / 20 * np.pi) yerr = np.linspace(0.05, 0.2, 10) plt.errorbar(x, y + 3, yerr=yerr, label=&#39;both limits (default)&#39;) plt.errorbar(x, y + 2, yerr=yerr, uplims=True, label=&#39;uplims=True&#39;) plt.errorbar(x, y + 1, yerr=yerr, uplims=True, lolims=True, label=&#39;uplims=True, lolims=True&#39;) upperlimits = [True, False] * 5 lowerlimits = [False, True] * 5 plt.errorbar(x, y, yerr=yerr, uplims=upperlimits, lolims=lowerlimits, label=&#39;subsets of uplims and lolims&#39;) plt.legend(loc=&#39;lower right&#39;) . &lt;matplotlib.legend.Legend at 0x25bea721d88&gt; .",
            "url": "https://bielsnor.github.io/futureproof/futureproof-testplots/",
            "relUrl": "/futureproof-testplots/",
            "date": " • Jun 27, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "COVID19 Models by US State",
            "content": "Covid Tracking Dataset (w/ hospitalised data) . Source: https://covidtracking.com/ Latest data and plots: https://github.com/bielsnor/futureproof/tree/master/_notebooks/results . Load and Clean the Data . Missing values: Retrieving from other datasets or through merging columns (or both) . The following will be done: . Active Cases: Retrieved from JHU dataset and calculating $active = pos-dead-recovered$ | Beds per State: Retrieved from External Datasets | . # TODO all_cases[&#39;active&#39;] = all_cases[&#39;positive&#39;] - all_cases[&#39;recovered&#39;] - all_cases[&#39;death&#39;] # change location of &#39;active&#39; column cols = list(all_cases) cols.insert(3, cols.pop(cols.index(&#39;active&#39;))) all_cases = all_cases.loc[:, cols] . # Load datasets for US population and Hospital beds per 1000 us_population = pd.read_csv(&#39;data/us_population.csv&#39;) hosp_beds = pd.read_csv(&#39;data/hospital_beds.csv&#39;) state_abbrev = pd.read_csv(&#39;data/us_state_names.csv&#39;) # add state abbreviations to us_population and hospital beds dataframe for state in state_abbrev[&#39;State&#39;].tolist(): # store state abbreviation in variable abbrev = state_abbrev.loc[state_abbrev[&#39;State&#39;] == state, &#39;Abbreviation&#39;].tolist()[0] # add abbrev to new column &#39;Abbreviation&#39; in us_population df us_population.loc[us_population[&#39;State&#39;] == state, &#39;Abbreviation&#39;] = abbrev # add abbrev to new column in hosp_beds df hosp_beds.loc[hosp_beds[&#39;Location&#39;] == state, &#39;Abbreviation&#39;] = abbrev # change order of columns of us_population cols = list(us_population) cols.insert(2, cols.pop(cols.index(&#39;Abbreviation&#39;))) us_population = us_population.loc[:, cols] # drop unnecessary columns of us_population us_population = us_population.drop(columns=[&#39;rank&#39;, &#39;Growth&#39;, &#39;Pop2018&#39;, &#39;Pop2010&#39;, &#39;growthSince2010&#39;, &#39;Percent&#39;, &#39;density&#39;]) # drop unnecessary columns of hosp_beds hosp_beds = hosp_beds.drop(columns=[&#39;Location&#39;, &#39;State/Local Government&#39;, &#39;Non-Profit&#39;, &#39;For-Profit&#39;]) # change order of columns of hosp_beds cols = list(hosp_beds) cols.insert(0, cols.pop(cols.index(&#39;Abbreviation&#39;))) hosp_beds = hosp_beds.loc[:, cols] . # filter out non-existing states like &#39;AS&#39; all_cases = all_cases[all_cases[&#39;state&#39;].isin(state_abbrev[&#39;Abbreviation&#39;].tolist())] . # Split dataframes by date df_split_by_date = dict(tuple(all_cases.groupby(&#39;date&#39;))) # Split dataframes by state df_split_by_state = dict(tuple(all_cases.groupby(&#39;state&#39;))) . # merge dataframes us_population and all_cases df_merge_uspop = all_cases.merge(us_population, how=&#39;left&#39;, left_on=&#39;state&#39;, right_on=&#39;Abbreviation&#39;) df_merge_uspop = df_merge_uspop.drop(columns=[&#39;Abbreviation&#39;]) df_merge_uspop = df_merge_uspop.rename(columns={&#39;Pop&#39;: &#39;population&#39;}) # change location of &#39;population&#39; column cols = list(df_merge_uspop) cols.insert(2, cols.pop(cols.index(&#39;population&#39;))) df_merge_uspop = df_merge_uspop.loc[:, cols] # merge dataframes hosp_beds and df_merge_uspop df_merge_hosp = df_merge_uspop.merge(hosp_beds, how=&#39;left&#39;, left_on=&#39;state&#39;, right_on=&#39;Abbreviation&#39;) df_merge_hosp = df_merge_hosp.drop(columns=[&#39;Abbreviation&#39;]) all_cases = df_merge_hosp.rename(columns={&#39;Total&#39;: &#39;bedsPerThousand&#39;}) . # Calculate the total beds, and add the column all_cases[&#39;total_beds&#39;] = all_cases[&#39;population&#39;] / 1000 * all_cases[&#39;bedsPerThousand&#39;] . # change abbreviations to state names all_cases = all_cases.rename(columns={&#39;state&#39;: &#39;abbrev&#39;}) all_cases = all_cases.rename(columns={&#39;State&#39;: &#39;state&#39;}) . # change location of &#39;state&#39; column cols = list(all_cases) cols.insert(1, cols.pop(cols.index(&#39;state&#39;))) all_cases = all_cases.loc[:, cols] . #print data frame head for spot visual data verification all_cases . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-27 | Alaska | AK | 734002 | 854.0 | 319.0 | 11.0 | NaN | NaN | 1.0 | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 2.2 | 1614.8044 | . 1 2020-06-27 | Alabama | AL | 4908621 | 35083.0 | 15298.0 | 655.0 | 2697.0 | NaN | NaN | ... | NaN | 34605.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.1 | 15216.7251 | . 2 2020-06-27 | Arkansas | AR | 3038999 | 18740.0 | 5707.0 | 284.0 | 1337.0 | NaN | 63.0 | ... | NaN | 18740.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.2 | 9724.7968 | . 3 2020-06-27 | Arizona | AZ | 7378494 | 70051.0 | 59813.0 | 2577.0 | 4595.0 | 657.0 | 433.0 | ... | NaN | 69641.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 14019.1386 | . 4 2020-06-27 | California | CA | 39937489 | 206433.0 | NaN | 5790.0 | NaN | 1562.0 | NaN | ... | NaN | 206433.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.8 | 71887.4802 | . 5 2020-06-27 | Colorado | CO | 5845526 | 31796.0 | 25693.0 | 226.0 | 5392.0 | NaN | NaN | ... | NaN | 28972.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 11106.4994 | . 6 2020-06-27 | Connecticut | CT | 3563077 | 46206.0 | 33842.0 | 106.0 | 10268.0 | NaN | NaN | ... | NaN | 44225.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.0 | 7126.1540 | . 7 2020-06-27 | District of Columbia | DC | 720687 | 10216.0 | 8474.0 | 136.0 | NaN | 43.0 | 26.0 | ... | NaN | 10216.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.4 | 3171.0228 | . 8 2020-06-27 | Delaware | DE | 982895 | 11091.0 | 3919.0 | 83.0 | NaN | 15.0 | NaN | ... | NaN | 10047.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.2 | 2162.3690 | . 9 2020-06-27 | Florida | FL | 21992985 | 132545.0 | NaN | NaN | 14432.0 | NaN | NaN | ... | 2010839.0 | 132545.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.6 | 57181.7610 | . 10 2020-06-27 | Georgia | GA | 10736059 | 74985.0 | NaN | 1178.0 | 10689.0 | NaN | NaN | ... | 721245.0 | 74985.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.4 | 25766.5416 | . 11 2020-06-27 | Hawaii | HI | 1412687 | 866.0 | 144.0 | NaN | 109.0 | NaN | NaN | ... | 85598.0 | 866.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 2684.1053 | . 12 2020-06-27 | Iowa | IA | 3179849 | 28012.0 | 9841.0 | 131.0 | NaN | 40.0 | 22.0 | ... | NaN | 28012.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.0 | 9539.5470 | . 13 2020-06-27 | Idaho | ID | 1826156 | 5148.0 | 1231.0 | NaN | 309.0 | NaN | NaN | ... | NaN | 4629.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 3469.6964 | . 14 2020-06-27 | Illinois | IL | 12659682 | 142130.0 | NaN | 1516.0 | NaN | 400.0 | 225.0 | ... | NaN | 141077.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 31649.2050 | . 15 2020-06-27 | Indiana | IN | 6745354 | 44575.0 | 8234.0 | 595.0 | 6982.0 | 257.0 | 82.0 | ... | NaN | 44575.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.7 | 18212.4558 | . 16 2020-06-27 | Kansas | KS | 2910357 | 13538.0 | 12495.0 | NaN | 1128.0 | NaN | NaN | ... | NaN | 13538.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 9604.1781 | . 17 2020-06-27 | Kentucky | KY | 4499692 | 14859.0 | 10576.0 | 387.0 | 2589.0 | 74.0 | NaN | ... | NaN | 14401.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.2 | 14399.0144 | . 18 2020-06-27 | Louisiana | LA | 4645184 | 54769.0 | 11787.0 | 700.0 | NaN | NaN | 73.0 | ... | NaN | 54769.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 15329.1072 | . 19 2020-06-27 | Massachusetts | MA | 6976597 | 108443.0 | NaN | 769.0 | 11310.0 | 143.0 | 90.0 | ... | NaN | 103376.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.3 | 16046.1731 | . 20 2020-06-27 | Maryland | MD | 6083116 | 66450.0 | 58358.0 | 478.0 | 10751.0 | 181.0 | NaN | ... | NaN | 66450.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 11557.9204 | . 21 2020-06-27 | Maine | ME | 1345790 | 3154.0 | 484.0 | 24.0 | 345.0 | 7.0 | 5.0 | ... | 87604.0 | 2809.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 3364.4750 | . 22 2020-06-27 | Michigan | MI | 10045029 | 69679.0 | 12427.0 | 557.0 | NaN | 193.0 | 106.0 | ... | 931142.0 | 63009.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 25112.5725 | . 23 2020-06-27 | Minnesota | MN | 5700671 | 35033.0 | 3180.0 | 300.0 | 3986.0 | 155.0 | NaN | ... | NaN | 35033.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 14251.6775 | . 24 2020-06-27 | Missouri | MO | 6169270 | 20261.0 | NaN | 680.0 | NaN | NaN | 66.0 | ... | 399926.0 | 20261.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.1 | 19124.7370 | . 25 2020-06-27 | Mississippi | MS | 2989260 | 25531.0 | 7254.0 | 731.0 | 3078.0 | 169.0 | 90.0 | ... | NaN | 25368.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.0 | 11957.0400 | . 26 2020-06-27 | Montana | MT | 1086759 | 852.0 | 226.0 | 9.0 | 95.0 | NaN | NaN | ... | NaN | 852.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 3586.3047 | . 27 2020-06-27 | North Carolina | NC | 10611862 | 60537.0 | 22304.0 | 888.0 | NaN | NaN | NaN | ... | NaN | 60537.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.1 | 22284.9102 | . 28 2020-06-27 | North Dakota | ND | 761723 | 3458.0 | 252.0 | 23.0 | 225.0 | NaN | NaN | ... | NaN | 3458.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.3 | 3275.4089 | . 29 2020-06-27 | Nebraska | NE | 1952570 | 18524.0 | 5560.0 | 125.0 | 1312.0 | NaN | NaN | ... | NaN | 18524.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.6 | 7029.2520 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 5851 2020-02-20 | Washington | WA | 7797095 | 82.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5852 2020-02-19 | Washington | WA | 7797095 | 69.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5853 2020-02-18 | Washington | WA | 7797095 | 59.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5854 2020-02-17 | Washington | WA | 7797095 | 50.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5855 2020-02-16 | Washington | WA | 7797095 | 35.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5856 2020-02-15 | Washington | WA | 7797095 | 28.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5857 2020-02-14 | Washington | WA | 7797095 | 21.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5858 2020-02-13 | Washington | WA | 7797095 | 18.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5859 2020-02-12 | Washington | WA | 7797095 | 18.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5860 2020-02-11 | Washington | WA | 7797095 | 17.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5861 2020-02-10 | Washington | WA | 7797095 | 16.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5862 2020-02-09 | Washington | WA | 7797095 | 13.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5863 2020-02-08 | Washington | WA | 7797095 | 13.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5864 2020-02-07 | Washington | WA | 7797095 | 12.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5865 2020-02-06 | Washington | WA | 7797095 | 11.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5866 2020-02-05 | Washington | WA | 7797095 | 8.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5867 2020-02-04 | Washington | WA | 7797095 | 8.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5868 2020-02-03 | Washington | WA | 7797095 | 7.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5869 2020-02-02 | Washington | WA | 7797095 | 6.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5870 2020-02-01 | Washington | WA | 7797095 | 4.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5871 2020-01-31 | Washington | WA | 7797095 | 3.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5872 2020-01-30 | Washington | WA | 7797095 | 3.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5873 2020-01-29 | Washington | WA | 7797095 | 3.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5874 2020-01-28 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5875 2020-01-27 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5876 2020-01-26 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5877 2020-01-25 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5878 2020-01-24 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5879 2020-01-23 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5880 2020-01-22 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5881 rows × 29 columns . Load and clean JHU data | Merge JHU dataset with main dataset | . # This cell takes some time, as it needs to connect to Kaggle Servers to retrieve data kaggle.api.authenticate() kaggle.api.dataset_download_files(&#39;benhamner/jhucovid19&#39;, path=&#39;./kaggle/input/jhucovid19/&#39;, unzip=True) . # Get Time-Series Data of cases as Pandas DataFrame dir_jhu = &#39;./kaggle/input/jhucovid19/csse_covid_19_data/csse_covid_19_daily_reports&#39; df_list = [] for dirname, _, files in os.walk(dir_jhu): for file in files: if &#39;gitignore&#39; not in file and &#39;README&#39; not in file: full_dir = os.path.join(dirname, file) df_list.append(pd.read_csv(full_dir)) jhu_df = pd.concat(df_list, axis=0, ignore_index=True, sort=True) # convert Last Update columns to datetime format jhu_df.loc[:, &#39;Last Update&#39;] = pd.to_datetime(jhu_df[&#39;Last Update&#39;]).apply(lambda x: x.date()) jhu_df.loc[:, &#39;Last_Update&#39;] = pd.to_datetime(jhu_df[&#39;Last_Update&#39;]).apply(lambda x: x.date()) # Combine Last Update with Last_Update jhu_df[&#39;LastUpdate&#39;] = jhu_df[&#39;Last_Update&#39;].combine_first(jhu_df[&#39;Last Update&#39;]) # Combine Country/Region with Country_Region jhu_df[&#39;CountryRegion&#39;] = jhu_df[&#39;Country/Region&#39;].combine_first(jhu_df[&#39;Country_Region&#39;]) # Retrieve only US data jhu_df = jhu_df[jhu_df[&#39;CountryRegion&#39;]==&#39;US&#39;] # Combine Province/State with Province_State jhu_df[&#39;ProvinceState&#39;] = jhu_df[&#39;Province/State&#39;].combine_first(jhu_df[&#39;Province_State&#39;]) # Drop unnecessary columns jhu_df = jhu_df.drop([&#39;Admin2&#39;, &#39;Lat&#39;, &#39;Latitude&#39;, &#39;Long_&#39;, &#39;Longitude&#39;, &#39;Combined_Key&#39;, &#39;Country/Region&#39;, &#39;Country_Region&#39;, &#39;Province/State&#39;, &#39;Province_State&#39;, &#39;Last Update&#39;, &#39;Last_Update&#39;, &#39;FIPS&#39;], axis=1) # Change column order cols = list(jhu_df) cols.insert(0, cols.pop(cols.index(&#39;CountryRegion&#39;))) cols.insert(1, cols.pop(cols.index(&#39;ProvinceState&#39;))) cols.insert(2, cols.pop(cols.index(&#39;LastUpdate&#39;))) jhu_df = jhu_df.loc[:, cols] # Change region to known US states state_abbrs_dict = {} for state in us.states.STATES: state_abbrs_dict[state.abbr] = state.name def toState(input_state, mapping): abbreviation = input_state.rstrip()[-2:] try: return_value = mapping[abbreviation] except KeyError: return_value = input_state return return_value jhu_df[&#39;ProvinceState&#39;] = jhu_df[&#39;ProvinceState&#39;].apply(lambda x: toState(x, state_abbrs_dict) if x != &#39;Washington, D.C.&#39; else &#39;District of Columbia&#39;) # Filter out unknown states jhu_df = jhu_df[jhu_df[&#39;ProvinceState&#39;].isin(all_cases.state.unique().tolist())] # Merge-sum rows with same date and State jhu_df = jhu_df.groupby([&#39;LastUpdate&#39;, &#39;ProvinceState&#39;]).agg( { &#39;Active&#39;: sum, &#39;Confirmed&#39;: sum, &#39;Deaths&#39;: sum, &#39;Recovered&#39;: sum } ).reset_index() jhu_df.tail() . LastUpdate ProvinceState Active Confirmed Deaths Recovered . 5190 2020-06-19 | Virginia | 54652.0 | 56238.0 | 1586.0 | 0.0 | . 5191 2020-06-19 | Washington | 25947.0 | 27192.0 | 1245.0 | 0.0 | . 5192 2020-06-19 | West Virginia | 2330.0 | 2418.0 | 88.0 | 0.0 | . 5193 2020-06-19 | Wisconsin | 23157.0 | 23876.0 | 719.0 | 0.0 | . 5194 2020-06-19 | Wyoming | 1126.0 | 1144.0 | 18.0 | 0.0 | . # Now that we have the JHU dataset relatively cleaned # we can go ahead and merge its data with our main dataset for i, row in all_cases.iterrows(): last_update = all_cases.at[i, &#39;date&#39;] state = all_cases.at[i, &#39;state&#39;] matching_row = jhu_df[jhu_df[&#39;ProvinceState&#39;] == state] matching_row = matching_row[matching_row[&#39;LastUpdate&#39;] == last_update].reset_index() if len(matching_row.values) &gt; 0: #all_cases.at[i, &#39;positive&#39;] = matching_row[&#39;Confirmed&#39;].values[0] all_cases.at[i, &#39;active&#39;] = matching_row[&#39;Active&#39;].values[0] #all_cases.at[i, &#39;recovered&#39;] = matching_row[&#39;Recovered&#39;].values[0] JHU was inconsistent, therefore removed #all_cases.at[i, &#39;death&#39;] = matching_row[&#39;Deaths&#39;].values[0] # Replace unknown recovery numbers with 0 if np.isnan(row[&#39;recovered&#39;]): all_cases.at[i, &#39;recovered&#39;] = 0 if all_cases.at[i, &#39;active&#39;] == 0 or np.isnan(row[&#39;active&#39;]): positive = all_cases.at[i, &#39;positive&#39;] recovered = all_cases.at[i, &#39;recovered&#39;] dead = all_cases.at[i, &#39;death&#39;] all_cases.at[i, &#39;active&#39;] = positive - recovered - dead #all_cases.tail() all_cases . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-27 | Alaska | AK | 734002 | 854.0 | 319.0 | 11.0 | NaN | NaN | 1.0 | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 2.2 | 1614.8044 | . 1 2020-06-27 | Alabama | AL | 4908621 | 35083.0 | 15298.0 | 655.0 | 2697.0 | NaN | NaN | ... | NaN | 34605.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.1 | 15216.7251 | . 2 2020-06-27 | Arkansas | AR | 3038999 | 18740.0 | 5707.0 | 284.0 | 1337.0 | NaN | 63.0 | ... | NaN | 18740.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.2 | 9724.7968 | . 3 2020-06-27 | Arizona | AZ | 7378494 | 70051.0 | 59813.0 | 2577.0 | 4595.0 | 657.0 | 433.0 | ... | NaN | 69641.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 14019.1386 | . 4 2020-06-27 | California | CA | 39937489 | 206433.0 | 200561.0 | 5790.0 | NaN | 1562.0 | NaN | ... | NaN | 206433.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.8 | 71887.4802 | . 5 2020-06-27 | Colorado | CO | 5845526 | 31796.0 | 25693.0 | 226.0 | 5392.0 | NaN | NaN | ... | NaN | 28972.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 11106.4994 | . 6 2020-06-27 | Connecticut | CT | 3563077 | 46206.0 | 33842.0 | 106.0 | 10268.0 | NaN | NaN | ... | NaN | 44225.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.0 | 7126.1540 | . 7 2020-06-27 | District of Columbia | DC | 720687 | 10216.0 | 8474.0 | 136.0 | NaN | 43.0 | 26.0 | ... | NaN | 10216.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.4 | 3171.0228 | . 8 2020-06-27 | Delaware | DE | 982895 | 11091.0 | 3919.0 | 83.0 | NaN | 15.0 | NaN | ... | NaN | 10047.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.2 | 2162.3690 | . 9 2020-06-27 | Florida | FL | 21992985 | 132545.0 | 129056.0 | NaN | 14432.0 | NaN | NaN | ... | 2010839.0 | 132545.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.6 | 57181.7610 | . 10 2020-06-27 | Georgia | GA | 10736059 | 74985.0 | 72209.0 | 1178.0 | 10689.0 | NaN | NaN | ... | 721245.0 | 74985.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.4 | 25766.5416 | . 11 2020-06-27 | Hawaii | HI | 1412687 | 866.0 | 144.0 | NaN | 109.0 | NaN | NaN | ... | 85598.0 | 866.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 2684.1053 | . 12 2020-06-27 | Iowa | IA | 3179849 | 28012.0 | 9841.0 | 131.0 | NaN | 40.0 | 22.0 | ... | NaN | 28012.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.0 | 9539.5470 | . 13 2020-06-27 | Idaho | ID | 1826156 | 5148.0 | 1231.0 | NaN | 309.0 | NaN | NaN | ... | NaN | 4629.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 3469.6964 | . 14 2020-06-27 | Illinois | IL | 12659682 | 142130.0 | 135056.0 | 1516.0 | NaN | 400.0 | 225.0 | ... | NaN | 141077.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 31649.2050 | . 15 2020-06-27 | Indiana | IN | 6745354 | 44575.0 | 8234.0 | 595.0 | 6982.0 | 257.0 | 82.0 | ... | NaN | 44575.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.7 | 18212.4558 | . 16 2020-06-27 | Kansas | KS | 2910357 | 13538.0 | 12495.0 | NaN | 1128.0 | NaN | NaN | ... | NaN | 13538.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 9604.1781 | . 17 2020-06-27 | Kentucky | KY | 4499692 | 14859.0 | 10576.0 | 387.0 | 2589.0 | 74.0 | NaN | ... | NaN | 14401.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.2 | 14399.0144 | . 18 2020-06-27 | Louisiana | LA | 4645184 | 54769.0 | 11787.0 | 700.0 | NaN | NaN | 73.0 | ... | NaN | 54769.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 15329.1072 | . 19 2020-06-27 | Massachusetts | MA | 6976597 | 108443.0 | 100402.0 | 769.0 | 11310.0 | 143.0 | 90.0 | ... | NaN | 103376.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.3 | 16046.1731 | . 20 2020-06-27 | Maryland | MD | 6083116 | 66450.0 | 58358.0 | 478.0 | 10751.0 | 181.0 | NaN | ... | NaN | 66450.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 11557.9204 | . 21 2020-06-27 | Maine | ME | 1345790 | 3154.0 | 484.0 | 24.0 | 345.0 | 7.0 | 5.0 | ... | 87604.0 | 2809.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 3364.4750 | . 22 2020-06-27 | Michigan | MI | 10045029 | 69679.0 | 12427.0 | 557.0 | NaN | 193.0 | 106.0 | ... | 931142.0 | 63009.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 25112.5725 | . 23 2020-06-27 | Minnesota | MN | 5700671 | 35033.0 | 3180.0 | 300.0 | 3986.0 | 155.0 | NaN | ... | NaN | 35033.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 14251.6775 | . 24 2020-06-27 | Missouri | MO | 6169270 | 20261.0 | 19265.0 | 680.0 | NaN | NaN | 66.0 | ... | 399926.0 | 20261.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.1 | 19124.7370 | . 25 2020-06-27 | Mississippi | MS | 2989260 | 25531.0 | 7254.0 | 731.0 | 3078.0 | 169.0 | 90.0 | ... | NaN | 25368.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.0 | 11957.0400 | . 26 2020-06-27 | Montana | MT | 1086759 | 852.0 | 226.0 | 9.0 | 95.0 | NaN | NaN | ... | NaN | 852.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 3586.3047 | . 27 2020-06-27 | North Carolina | NC | 10611862 | 60537.0 | 22304.0 | 888.0 | NaN | NaN | NaN | ... | NaN | 60537.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.1 | 22284.9102 | . 28 2020-06-27 | North Dakota | ND | 761723 | 3458.0 | 252.0 | 23.0 | 225.0 | NaN | NaN | ... | NaN | 3458.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.3 | 3275.4089 | . 29 2020-06-27 | Nebraska | NE | 1952570 | 18524.0 | 5560.0 | 125.0 | 1312.0 | NaN | NaN | ... | NaN | 18524.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.6 | 7029.2520 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 5851 2020-02-20 | Washington | WA | 7797095 | 82.0 | 82.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5852 2020-02-19 | Washington | WA | 7797095 | 69.0 | 69.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5853 2020-02-18 | Washington | WA | 7797095 | 59.0 | 59.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5854 2020-02-17 | Washington | WA | 7797095 | 50.0 | 50.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5855 2020-02-16 | Washington | WA | 7797095 | 35.0 | 35.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5856 2020-02-15 | Washington | WA | 7797095 | 28.0 | 28.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5857 2020-02-14 | Washington | WA | 7797095 | 21.0 | 21.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5858 2020-02-13 | Washington | WA | 7797095 | 18.0 | 18.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5859 2020-02-12 | Washington | WA | 7797095 | 18.0 | 18.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5860 2020-02-11 | Washington | WA | 7797095 | 17.0 | 17.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5861 2020-02-10 | Washington | WA | 7797095 | 16.0 | 16.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5862 2020-02-09 | Washington | WA | 7797095 | 13.0 | 13.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5863 2020-02-08 | Washington | WA | 7797095 | 13.0 | 13.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5864 2020-02-07 | Washington | WA | 7797095 | 12.0 | 12.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5865 2020-02-06 | Washington | WA | 7797095 | 11.0 | 11.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5866 2020-02-05 | Washington | WA | 7797095 | 8.0 | 8.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5867 2020-02-04 | Washington | WA | 7797095 | 8.0 | 8.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5868 2020-02-03 | Washington | WA | 7797095 | 7.0 | 7.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5869 2020-02-02 | Washington | WA | 7797095 | 6.0 | 6.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5870 2020-02-01 | Washington | WA | 7797095 | 4.0 | 4.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5871 2020-01-31 | Washington | WA | 7797095 | 3.0 | 3.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5872 2020-01-30 | Washington | WA | 7797095 | 3.0 | 3.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5873 2020-01-29 | Washington | WA | 7797095 | 3.0 | 3.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5874 2020-01-28 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5875 2020-01-27 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5876 2020-01-26 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5877 2020-01-25 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5878 2020-01-24 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5879 2020-01-23 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5880 2020-01-22 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5881 rows × 29 columns . # Save formatted dataset offline in case of disaster dataset_file = &#39;results/all_cases.csv&#39; all_cases.to_csv(dataset_file) . # convert date to datetime format all_cases[&#39;date&#39;] = pd.to_datetime(all_cases[&#39;date&#39;]) . An Exploratory data analysis of the US dataset . Basic triad of the dataset: validating data types and data integrity of each row . dataset_file = &#39;results/all_cases.csv&#39; covid_df = pd.read_csv(dataset_file, index_col=0) # convert date to datetime format covid_df[&#39;date&#39;] = pd.to_datetime(covid_df[&#39;date&#39;]) covid_df.info() # set float format to 3 decimals pd.set_option(&#39;display.float_format&#39;, lambda x: &#39;%.3f&#39; % x) . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 5881 entries, 0 to 5880 Data columns (total 29 columns): date 5881 non-null datetime64[ns] state 5881 non-null object abbrev 5881 non-null object population 5881 non-null int64 positive 5881 non-null float64 active 5881 non-null float64 hospitalizedCurrently 3598 non-null float64 hospitalizedCumulative 3198 non-null float64 inIcuCurrently 1858 non-null float64 onVentilatorCurrently 1653 non-null float64 recovered 5881 non-null float64 dataQualityGrade 4947 non-null object lastUpdateEt 5526 non-null object dateModified 5526 non-null object checkTimeEt 5526 non-null object death 5881 non-null float64 hospitalized 3198 non-null float64 totalTestsViral 1568 non-null float64 positiveTestsViral 525 non-null float64 negativeTestsViral 524 non-null float64 positiveCasesViral 3059 non-null float64 commercialScore 5881 non-null int64 negativeRegularScore 5881 non-null int64 negativeScore 5881 non-null int64 positiveScore 5881 non-null int64 score 5881 non-null int64 grade 0 non-null float64 bedsPerThousand 5881 non-null float64 total_beds 5881 non-null float64 dtypes: datetime64[ns](1), float64(16), int64(6), object(6) memory usage: 1.3+ MB . covid_df.head() . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-27 | Alaska | AK | 734002 | 854.000 | 319.000 | 11.000 | nan | nan | 1.000 | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 2.200 | 1614.804 | . 1 2020-06-27 | Alabama | AL | 4908621 | 35083.000 | 15298.000 | 655.000 | 2697.000 | nan | nan | ... | nan | 34605.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.100 | 15216.725 | . 2 2020-06-27 | Arkansas | AR | 3038999 | 18740.000 | 5707.000 | 284.000 | 1337.000 | nan | 63.000 | ... | nan | 18740.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.200 | 9724.797 | . 3 2020-06-27 | Arizona | AZ | 7378494 | 70051.000 | 59813.000 | 2577.000 | 4595.000 | 657.000 | 433.000 | ... | nan | 69641.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 14019.139 | . 4 2020-06-27 | California | CA | 39937489 | 206433.000 | 200561.000 | 5790.000 | nan | 1562.000 | nan | ... | nan | 206433.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.800 | 71887.480 | . 5 rows × 29 columns . The NaN values may indicate that there were no to few Covid-19 patients at these date points. We further analyse the statistical values of the dataset columns to ensure data integrity and accuracy. . covid_df.describe() # TODO rounding up the numbers . population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently recovered death hospitalized ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . count 5881.000 | 5881.000 | 5881.000 | 3598.000 | 3198.000 | 1858.000 | 1653.000 | 5881.000 | 5881.000 | 3198.000 | ... | 524.000 | 3059.000 | 5881.000 | 5881.000 | 5881.000 | 5881.000 | 5881.000 | 0.000 | 5881.000 | 5881.000 | . mean 6543367.585 | 20916.359 | 18615.094 | 1028.274 | 4343.898 | 444.164 | 226.540 | 4396.344 | 1091.030 | 4343.898 | ... | 288695.632 | 31980.345 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 2.625 | 15806.903 | . std 7387134.109 | 46506.152 | 41859.038 | 1934.647 | 12924.575 | 695.599 | 330.534 | 10915.396 | 2906.033 | 12924.575 | ... | 383203.556 | 56469.631 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 0.744 | 16159.795 | . min 567025.000 | 0.000 | 0.000 | 1.000 | 0.000 | 2.000 | 0.000 | 0.000 | 0.000 | 0.000 | ... | 17.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 1.600 | 1318.928 | . 25% 1778070.000 | 631.000 | 543.000 | 121.000 | 219.250 | 82.000 | 36.000 | 0.000 | 12.000 | 219.250 | ... | 49528.250 | 5009.500 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 2.100 | 3773.952 | . 50% 4499692.000 | 5025.000 | 4494.000 | 402.000 | 954.000 | 185.500 | 94.000 | 206.000 | 144.000 | 954.000 | ... | 138808.000 | 13637.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 2.500 | 11557.920 | . 75% 7797095.000 | 20595.000 | 17382.000 | 1037.750 | 3215.750 | 487.000 | 250.000 | 3064.000 | 772.000 | 3215.750 | ... | 354942.750 | 35269.500 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 3.100 | 19124.737 | . max 39937489.000 | 391923.000 | 356899.000 | 18825.000 | 89995.000 | 5225.000 | 2425.000 | 78248.000 | 24830.000 | 89995.000 | ... | 2010839.000 | 391923.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 4.800 | 71887.480 | . 8 rows × 22 columns . # drop unnecessary columns covid_cleaned = covid_df.drop([&#39;hospitalized&#39;, &#39;bedsPerThousand&#39;], axis=1) covid_100k = covid_cleaned.copy() # list of columns to transform to per 100k columns_list = [&#39;positive&#39;, &#39;active&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;onVentilatorCurrently&#39;, &#39;total_beds&#39;, &#39;totalTestsViral&#39;] # add columns per 100k for column in columns_list: if column == &#39;total_beds&#39;: covid_100k[&#39;BedsPer100k&#39;.format(column)] = (covid_cleaned.loc[:, column] / covid_cleaned.loc[:, &#39;population&#39;]) * 100000 else: covid_100k[&#39;{}_100k&#39;.format(column)] = (covid_cleaned.loc[:, column] / covid_cleaned.loc[:, &#39;population&#39;]) * 100000 covid_100k = covid_100k.drop(columns_list, axis=1) . covid_100k[&#39;date&#39;] = pd.to_datetime(covid_100k[&#39;date&#39;]) start_date = &#39;2020-04-18&#39; end_date = &#39;2020-05-19&#39; mask = (covid_100k[&#39;date&#39;] &gt; start_date) &amp; (covid_100k[&#39;date&#39;] &lt;= end_date) covid_100k_last_month = covid_100k.loc[mask] . covid_100k_last_month_part1 = covid_100k_last_month.groupby(&#39;date&#39;).sum().loc[:, [&#39;positive_100k&#39;,&#39;active_100k&#39;,&#39;recovered_100k&#39;,&#39;death_100k&#39;,&#39;hospitalizedCumulative_100k&#39;]].diff(periods=1, axis=0) covid_100k_last_month_part2 = covid_100k_last_month.groupby(&#39;date&#39;).sum().loc[:, [&#39;inIcuCurrently_100k&#39;,&#39;onVentilatorCurrently_100k&#39;,&#39;BedsPer100k&#39;]] final_100k_last_month = covid_100k_last_month_part1.merge(covid_100k_last_month_part2, left_index=True, right_index=True) . final_100k_last_month.head() . positive_100k active_100k recovered_100k death_100k hospitalizedCumulative_100k inIcuCurrently_100k onVentilatorCurrently_100k BedsPer100k . date . 2020-04-19 nan | nan | nan | nan | nan | 153.528 | 80.717 | 13440.000 | . 2020-04-20 413.759 | 391.692 | 35.481 | 25.728 | 22.652 | 156.581 | 79.710 | 13440.000 | . 2020-04-21 387.394 | 360.446 | 65.218 | 30.520 | 31.446 | 166.081 | 78.603 | 13440.000 | . 2020-04-22 428.601 | 989.954 | 412.625 | 28.780 | 36.181 | 167.561 | 78.032 | 13440.000 | . 2020-04-23 452.031 | -2213.482 | 72.921 | 26.282 | 28.842 | 166.277 | 94.521 | 13440.000 | . final_100k_last_month.describe() . positive_100k active_100k recovered_100k death_100k hospitalizedCumulative_100k inIcuCurrently_100k onVentilatorCurrently_100k BedsPer100k . count 30.000 | 30.000 | 30.000 | 30.000 | 30.000 | 31.000 | 31.000 | 31.000 | . mean 399.188 | 364.943 | 147.172 | 23.271 | 39.160 | 134.117 | 73.503 | 13440.000 | . std 58.939 | 634.169 | 81.341 | 5.781 | 43.524 | 19.860 | 8.141 | 0.000 | . min 287.019 | -2213.482 | 35.481 | 13.315 | 9.507 | 109.602 | 61.622 | 13440.000 | . 25% 348.980 | 314.204 | 80.563 | 18.439 | 22.991 | 118.222 | 66.261 | 13440.000 | . 50% 405.026 | 366.234 | 127.774 | 24.119 | 28.295 | 127.613 | 74.706 | 13440.000 | . 75% 432.647 | 419.664 | 212.491 | 26.201 | 32.754 | 149.768 | 79.157 | 13440.000 | . max 544.349 | 2291.210 | 412.625 | 33.917 | 246.371 | 167.561 | 94.521 | 13440.000 | . # Timeseries plot fig, ax = plt.subplots(figsize = (16, 10)) ax.plot(covid_df.date, covid_df.hospitalizedCurrently) ax.set_title(&#39;Number of USA Patients Currently in ICU&#39;) # TODO change the X-axis to chip the year # TODO which timeseries plots do we need? # TODO how to temporarily remove the outliers? . Text(0.5, 1.0, &#39;Number of USA Patients Currently in ICU&#39;) . # save description cleaned dataset to csv describe_file = &#39;results/final_100k_last_month.csv&#39; final_100k_last_month.describe().to_csv(describe_file) . Graphical Exploratory Analysis . Plotting histograms, scatterplots and boxplots to assess the distribution of the entire US dataset. . # Omitting the categorical (states/abbreviations) and time columns # There must be an easier way for you, but this was the easiest way I could think of covid_cleaned[&#39;date&#39;] = pd.to_datetime(covid_cleaned[&#39;date&#39;]) # mask data for last month start_date = &#39;2020-04-18&#39; end_date = &#39;2020-05-19&#39; mask = (covid_cleaned[&#39;date&#39;] &gt; start_date) &amp; (covid_cleaned[&#39;date&#39;] &lt;= end_date) covid_cleaned_last_month = covid_cleaned.loc[mask] plot_df = covid_cleaned_last_month[[&#39;population&#39;, &#39;active&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;onVentilatorCurrently&#39;, &#39;total_beds&#39;]] plot_df_last_month = covid_100k_last_month[[&#39;population&#39;, &#39;active_100k&#39;, &#39;recovered_100k&#39;, &#39;death_100k&#39;, &#39;hospitalizedCurrently_100k&#39;, &#39;inIcuCurrently_100k&#39;, &#39;onVentilatorCurrently_100k&#39;, &#39;BedsPer100k&#39;]] . timeseries_usa_df = covid_100k.loc[:, [&#39;date&#39;, &#39;positive_100k&#39;, &#39;active_100k&#39;, &#39;recovered_100k&#39;, &#39;death_100k&#39;, &#39;hospitalizedCurrently_100k&#39;, &#39;inIcuCurrently_100k&#39;, &#39;onVentilatorCurrently_100k&#39;, &#39;BedsPer100k&#39;]].groupby(&#39;date&#39;).sum().reset_index() # timeseries_usa_df[&#39;log_positive&#39;] = np.log(timeseries_usa_df[&#39;positive_100k&#39;]) # timeseries_usa_df[&#39;log_active&#39;] = np.log(timeseries_usa_df[&#39;active_100k&#39;]) # timeseries_usa_df[&#39;log_recovered&#39;] = np.log(timeseries_usa_df[&#39;recovered_100k&#39;]) # timeseries_usa_df[&#39;log_death&#39;] = np.log(timeseries_usa_df[&#39;death_100k&#39;]) . timeseries_usa_df.tail() . date positive_100k active_100k recovered_100k death_100k hospitalizedCurrently_100k inIcuCurrently_100k onVentilatorCurrently_100k BedsPer100k . 153 2020-06-23 | 32860.514 | 19133.883 | 12183.722 | 1542.909 | 403.069 | 71.078 | 37.684 | 13440.000 | . 154 2020-06-24 | 33315.285 | 19401.954 | 12359.391 | 1553.940 | 408.570 | 68.612 | 36.820 | 13440.000 | . 155 2020-06-25 | 33812.912 | 19730.969 | 12498.864 | 1583.079 | 414.087 | 67.864 | 36.962 | 13440.000 | . 156 2020-06-26 | 34335.924 | 20098.997 | 12643.998 | 1592.929 | 404.115 | 67.051 | 34.318 | 13440.000 | . 157 2020-06-27 | 34829.638 | 20417.559 | 12812.241 | 1599.839 | 407.257 | 68.533 | 35.118 | 13440.000 | . covid_df.head() . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-27 | Alaska | AK | 734002 | 854.000 | 319.000 | 11.000 | nan | nan | 1.000 | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 2.200 | 1614.804 | . 1 2020-06-27 | Alabama | AL | 4908621 | 35083.000 | 15298.000 | 655.000 | 2697.000 | nan | nan | ... | nan | 34605.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.100 | 15216.725 | . 2 2020-06-27 | Arkansas | AR | 3038999 | 18740.000 | 5707.000 | 284.000 | 1337.000 | nan | 63.000 | ... | nan | 18740.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.200 | 9724.797 | . 3 2020-06-27 | Arizona | AZ | 7378494 | 70051.000 | 59813.000 | 2577.000 | 4595.000 | 657.000 | 433.000 | ... | nan | 69641.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 14019.139 | . 4 2020-06-27 | California | CA | 39937489 | 206433.000 | 200561.000 | 5790.000 | nan | 1562.000 | nan | ... | nan | 206433.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.800 | 71887.480 | . 5 rows × 29 columns . # get data from last day # plot_df_last_date = plot_df.loc[covid_df[&#39;date&#39;] == &#39;2020-05-18&#39;] # Plotting histograms to gain insight of the distribution shape, skewness and scale fig, axs = plt.subplots(4,2,figsize = (16, 16)) sns.set() for i, column in enumerate(plot_df_last_month.columns): if (i + 1) % 2 == 0: ax = axs[(i//2), 1] else: ax = axs[(i//2), 0] sns.distplot(plot_df_last_month[column], fit=norm, fit_kws=dict(label=&#39;normality&#39;), hist_kws=dict(color=&#39;plum&#39;, edgecolor=&#39;k&#39;, linewidth=1, label=&#39;frequency&#39;), ax=ax, color=&#39;#9d53ad&#39;) ax.legend(loc=&#39;upper right&#39;) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Looking at linearity and variance with scatterplots # Removing the target variable and saving it in another df target = plot_df.hospitalizedCurrently indep_var = plot_df.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var.columns): ax=fig.add_subplot(4, 3, i+1) sns.regplot(x=indep_var[col], y=target, data=indep_var, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;, &#39;label&#39;: &#39;hospitCurr&#39;}) plt.suptitle(&#39;Scatterplots with Target Hospitalized Patients Showing Growth Trajectories&#39;, fontsize=18) plt.legend() plt.tight_layout() fig.subplots_adjust(top=0.95) . # Assessing the normality of the distribution with a boxplot # Boxplot with removed outliers fig, ax = plt.subplots(figsize = (16, 12)) for i, col in enumerate(plot_df.columns): ax=fig.add_subplot(4, 3, i+1) sns.boxplot(x=plot_df[col], data=plot_df, color=&#39;lightblue&#39;, showfliers=False) plt.suptitle(&#39;Boxplots of Independent Variables&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . # get data from last day plot_df_last_date = plot_df.loc[covid_df[&#39;date&#39;] == &#39;2020-05-18&#39;] fig, ax = plt.subplots(figsize = (16, 12)) for i, col in enumerate(plot_df_last_date.columns): ax=fig.add_subplot(4, 3, i+1) sns.boxplot(x=plot_df_last_date[col], data=plot_df, color=&#39;lightblue&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . Analysis of Hospitalizations, ICU Hospitilizations, Active Cases, New Cases, Deaths, and Recoveries by State . Since the normality of the independent variables is highly variable do to temporal and precision differences from each state, we further assess each state&#39;s data by viewing trends on the independent variables in both scatter and box-and-whisker plots. . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . C: Users Doctor Gomez AppData Roaming Python Python37 site-packages pandas plotting _converter.py:129: FutureWarning: Using an implicitly registered datetime converter for a matplotlib plotting method. The converter was registered by pandas on import. Future versions of pandas will require you to explicitly register matplotlib converters. To register the converters: &gt;&gt;&gt; from pandas.plotting import register_matplotlib_converters &gt;&gt;&gt; register_matplotlib_converters() . Text(0, 0.5, &#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . Alaska . # Split covid_df into subset with only NY values alaska = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;AK&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(alaska.date, alaska.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in AK Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Split covid_df into subset with only NY values alaska = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;AK&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(alaska.date, alaska.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in AK Currently on a Ventilator&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Split covid_df into subset with only NY values alaska = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;AK&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(alaska.date, alaska.recovered, linewidth=3.3) plt.title(&#39;Number of Recovered Cases in AK&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values alaska = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;AK&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(alaska.date, alaska.totalTestsViral, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in AK&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Split covid_df into subset with only NY values alaska = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;AK&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(alaska.date, alaska.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Viral Tests in AK&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . ###ENDALASKA . Alabama . # Split covid_df into subset with only NY values alabama = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;AL&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(alabama.date, alabama.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in AL Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Split covid_df into subset with only NY values alabama = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;AL&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(alabama.date, alabama.hospitalized, linewidth=3.3) plt.title(&#39;Number of Cummulative Hospitalizations in AL&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values alabama = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;AL&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(alabama.date, alabama.positiveCasesViral, linewidth=3.3) plt.title(&#39;Number of Positve Cases in AL&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values alabama = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;AL&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(alabama.date, alabama.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in AL&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . Assessing Correlation of Independent Variables . # TODO add some explanation / look more into collinear variables . # Heatmap of correlations # Save correlations to variable corr = covid_cleaned.corr(method=&#39;pearson&#39;) # We can create a mask to not show duplicate values mask = np.triu(np.ones_like(corr, dtype=np.bool)) # Set up the matplotlib figure fig, ax = plt.subplots(figsize=(16,16)) # Generate heatmap sns.heatmap(corr, annot=True, mask=mask, cmap=&#39;GnBu&#39;, center=0, square=True, linewidths=.5, cbar_kws={&quot;shrink&quot;: .5}) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x15a8cdfefc8&gt; . Build model for dependent Variable . To be used to predict current hospitalizations | Having more complete variables for in ICU currently and on Ventilator Currently will allow us to predict these numbers as well. | . # We compare three models: # - Polynomial Regression # - Linear Regression # - ElasticNet # Copy DFs to not mess up original one # We will use model_df for our regression model model_df = all_cases.copy() # Delete redundant rows for row in [&#39;abbrev&#39;, &#39;bedsPerThousand&#39;, &#39;hospitalized&#39;, &#39;state&#39;, &#39;hospitalizedCumulative&#39;, &#39;dataQualityGrade&#39;, &#39;lastUpdateEt&#39;]: del model_df[row] # Drop NaN values for hospitalizedCurrently model_df = model_df.dropna(subset=[&#39;hospitalizedCurrently&#39;]) # Drop Values with abnormal active-hospitalised ratios (outside Conf. Interval) model_df[&#39;ratio_hospital&#39;] = model_df[&#39;hospitalizedCurrently&#39;] / model_df[&#39;active&#39;] model_df = model_df[~(model_df[&#39;ratio_hospital&#39;] &gt;= model_df.ratio_hospital.quantile(0.99))] #model_df = model_df[~(model_df[&#39;ratio_hospital&#39;] &lt;= model_df[&#39;ratio_hospital&#39;].median())] del model_df[&#39;ratio_hospital&#39;] # Get peek of model to use model_df.describe() . population positive active hospitalizedCurrently inIcuCurrently onVentilatorCurrently recovered death totalTestsViral positiveTestsViral negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade total_beds . count 3562.000 | 3562.000 | 3562.000 | 3562.000 | 1809.000 | 1606.000 | 3562.000 | 3562.000 | 1100.000 | 391.000 | 390.000 | 2486.000 | 3562.000 | 3562.000 | 3562.000 | 3562.000 | 3562.000 | 0.000 | 3562.000 | . mean 6738367.173 | 31598.061 | 27926.641 | 1024.725 | 440.929 | 223.639 | 6908.870 | 1706.631 | 395184.981 | 25193.292 | 239433.431 | 36358.513 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 16013.196 | . std 7743293.297 | 56556.886 | 50952.935 | 1938.260 | 701.297 | 332.946 | 13332.619 | 3587.151 | 532521.958 | 26029.658 | 228868.150 | 61121.853 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 16519.227 | . min 567025.000 | 115.000 | 113.000 | 1.000 | 2.000 | 0.000 | 0.000 | 0.000 | 9055.000 | 407.000 | 8648.000 | 396.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 1318.928 | . 25% 1778070.000 | 3242.000 | 2827.250 | 117.250 | 81.000 | 34.250 | 0.000 | 90.000 | 86677.750 | 4128.000 | 62733.000 | 6399.750 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 3773.952 | . 50% 4645184.000 | 12139.500 | 10043.000 | 401.500 | 181.000 | 91.000 | 1268.500 | 470.000 | 217376.500 | 14046.000 | 168871.000 | 16292.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 11557.920 | . 75% 8626207.000 | 35012.250 | 29934.250 | 1030.250 | 471.000 | 240.000 | 6250.750 | 1585.250 | 479986.000 | 43919.500 | 295648.000 | 40458.500 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 19124.737 | . max 39937489.000 | 391923.000 | 356899.000 | 18825.000 | 5225.000 | 2425.000 | 78248.000 | 24830.000 | 3862310.000 | 86713.000 | 931142.000 | 391923.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 71887.480 | . #Printing data for visual verification. all_cases . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-27 | Alaska | AK | 734002 | 854.000 | 319.000 | 11.000 | nan | nan | 1.000 | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 2.200 | 1614.804 | . 1 2020-06-27 | Alabama | AL | 4908621 | 35083.000 | 15298.000 | 655.000 | 2697.000 | nan | nan | ... | nan | 34605.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.100 | 15216.725 | . 2 2020-06-27 | Arkansas | AR | 3038999 | 18740.000 | 5707.000 | 284.000 | 1337.000 | nan | 63.000 | ... | nan | 18740.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.200 | 9724.797 | . 3 2020-06-27 | Arizona | AZ | 7378494 | 70051.000 | 59813.000 | 2577.000 | 4595.000 | 657.000 | 433.000 | ... | nan | 69641.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 14019.139 | . 4 2020-06-27 | California | CA | 39937489 | 206433.000 | 200561.000 | 5790.000 | nan | 1562.000 | nan | ... | nan | 206433.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.800 | 71887.480 | . 5 2020-06-27 | Colorado | CO | 5845526 | 31796.000 | 25693.000 | 226.000 | 5392.000 | nan | nan | ... | nan | 28972.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 11106.499 | . 6 2020-06-27 | Connecticut | CT | 3563077 | 46206.000 | 33842.000 | 106.000 | 10268.000 | nan | nan | ... | nan | 44225.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.000 | 7126.154 | . 7 2020-06-27 | District of Columbia | DC | 720687 | 10216.000 | 8474.000 | 136.000 | nan | 43.000 | 26.000 | ... | nan | 10216.000 | 0 | 0 | 0 | 0 | 0 | nan | 4.400 | 3171.023 | . 8 2020-06-27 | Delaware | DE | 982895 | 11091.000 | 3919.000 | 83.000 | nan | 15.000 | nan | ... | nan | 10047.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.200 | 2162.369 | . 9 2020-06-27 | Florida | FL | 21992985 | 132545.000 | 129056.000 | nan | 14432.000 | nan | nan | ... | 2010839.000 | 132545.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.600 | 57181.761 | . 10 2020-06-27 | Georgia | GA | 10736059 | 74985.000 | 72209.000 | 1178.000 | 10689.000 | nan | nan | ... | 721245.000 | 74985.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.400 | 25766.542 | . 11 2020-06-27 | Hawaii | HI | 1412687 | 866.000 | 144.000 | nan | 109.000 | nan | nan | ... | 85598.000 | 866.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 2684.105 | . 12 2020-06-27 | Iowa | IA | 3179849 | 28012.000 | 9841.000 | 131.000 | nan | 40.000 | 22.000 | ... | nan | 28012.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.000 | 9539.547 | . 13 2020-06-27 | Idaho | ID | 1826156 | 5148.000 | 1231.000 | nan | 309.000 | nan | nan | ... | nan | 4629.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 3469.696 | . 14 2020-06-27 | Illinois | IL | 12659682 | 142130.000 | 135056.000 | 1516.000 | nan | 400.000 | 225.000 | ... | nan | 141077.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.500 | 31649.205 | . 15 2020-06-27 | Indiana | IN | 6745354 | 44575.000 | 8234.000 | 595.000 | 6982.000 | 257.000 | 82.000 | ... | nan | 44575.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.700 | 18212.456 | . 16 2020-06-27 | Kansas | KS | 2910357 | 13538.000 | 12495.000 | nan | 1128.000 | nan | nan | ... | nan | 13538.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.300 | 9604.178 | . 17 2020-06-27 | Kentucky | KY | 4499692 | 14859.000 | 10576.000 | 387.000 | 2589.000 | 74.000 | nan | ... | nan | 14401.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.200 | 14399.014 | . 18 2020-06-27 | Louisiana | LA | 4645184 | 54769.000 | 11787.000 | 700.000 | nan | nan | 73.000 | ... | nan | 54769.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.300 | 15329.107 | . 19 2020-06-27 | Massachusetts | MA | 6976597 | 108443.000 | 100402.000 | 769.000 | 11310.000 | 143.000 | 90.000 | ... | nan | 103376.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.300 | 16046.173 | . 20 2020-06-27 | Maryland | MD | 6083116 | 66450.000 | 58358.000 | 478.000 | 10751.000 | 181.000 | nan | ... | nan | 66450.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 11557.920 | . 21 2020-06-27 | Maine | ME | 1345790 | 3154.000 | 484.000 | 24.000 | 345.000 | 7.000 | 5.000 | ... | 87604.000 | 2809.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.500 | 3364.475 | . 22 2020-06-27 | Michigan | MI | 10045029 | 69679.000 | 12427.000 | 557.000 | nan | 193.000 | 106.000 | ... | 931142.000 | 63009.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.500 | 25112.573 | . 23 2020-06-27 | Minnesota | MN | 5700671 | 35033.000 | 3180.000 | 300.000 | 3986.000 | 155.000 | nan | ... | nan | 35033.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.500 | 14251.678 | . 24 2020-06-27 | Missouri | MO | 6169270 | 20261.000 | 19265.000 | 680.000 | nan | nan | 66.000 | ... | 399926.000 | 20261.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.100 | 19124.737 | . 25 2020-06-27 | Mississippi | MS | 2989260 | 25531.000 | 7254.000 | 731.000 | 3078.000 | 169.000 | 90.000 | ... | nan | 25368.000 | 0 | 0 | 0 | 0 | 0 | nan | 4.000 | 11957.040 | . 26 2020-06-27 | Montana | MT | 1086759 | 852.000 | 226.000 | 9.000 | 95.000 | nan | nan | ... | nan | 852.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.300 | 3586.305 | . 27 2020-06-27 | North Carolina | NC | 10611862 | 60537.000 | 22304.000 | 888.000 | nan | nan | nan | ... | nan | 60537.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.100 | 22284.910 | . 28 2020-06-27 | North Dakota | ND | 761723 | 3458.000 | 252.000 | 23.000 | 225.000 | nan | nan | ... | nan | 3458.000 | 0 | 0 | 0 | 0 | 0 | nan | 4.300 | 3275.409 | . 29 2020-06-27 | Nebraska | NE | 1952570 | 18524.000 | 5560.000 | 125.000 | 1312.000 | nan | nan | ... | nan | 18524.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.600 | 7029.252 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 5851 2020-02-20 | Washington | WA | 7797095 | 82.000 | 82.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5852 2020-02-19 | Washington | WA | 7797095 | 69.000 | 69.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5853 2020-02-18 | Washington | WA | 7797095 | 59.000 | 59.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5854 2020-02-17 | Washington | WA | 7797095 | 50.000 | 50.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5855 2020-02-16 | Washington | WA | 7797095 | 35.000 | 35.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5856 2020-02-15 | Washington | WA | 7797095 | 28.000 | 28.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5857 2020-02-14 | Washington | WA | 7797095 | 21.000 | 21.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5858 2020-02-13 | Washington | WA | 7797095 | 18.000 | 18.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5859 2020-02-12 | Washington | WA | 7797095 | 18.000 | 18.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5860 2020-02-11 | Washington | WA | 7797095 | 17.000 | 17.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5861 2020-02-10 | Washington | WA | 7797095 | 16.000 | 16.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5862 2020-02-09 | Washington | WA | 7797095 | 13.000 | 13.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5863 2020-02-08 | Washington | WA | 7797095 | 13.000 | 13.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5864 2020-02-07 | Washington | WA | 7797095 | 12.000 | 12.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5865 2020-02-06 | Washington | WA | 7797095 | 11.000 | 11.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5866 2020-02-05 | Washington | WA | 7797095 | 8.000 | 8.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5867 2020-02-04 | Washington | WA | 7797095 | 8.000 | 8.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5868 2020-02-03 | Washington | WA | 7797095 | 7.000 | 7.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5869 2020-02-02 | Washington | WA | 7797095 | 6.000 | 6.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5870 2020-02-01 | Washington | WA | 7797095 | 4.000 | 4.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5871 2020-01-31 | Washington | WA | 7797095 | 3.000 | 3.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5872 2020-01-30 | Washington | WA | 7797095 | 3.000 | 3.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5873 2020-01-29 | Washington | WA | 7797095 | 3.000 | 3.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5874 2020-01-28 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5875 2020-01-27 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5876 2020-01-26 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5877 2020-01-25 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5878 2020-01-24 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5879 2020-01-23 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5880 2020-01-22 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5881 rows × 29 columns . ### Mark Bee (https://www.facebook.com/markbeenyc) - do you need a sippy cup lesson on this information? .",
            "url": "https://bielsnor.github.io/futureproof/futureproof-COVID19-state-models/",
            "relUrl": "/futureproof-COVID19-state-models/",
            "date": " • Jun 27, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Various Covid Models by State",
            "content": "Covid Tracking Dataset (w/ hospitalised data) . Source: https://covidtracking.com/ Latest data and plots: https://github.com/bielsnor/futureproof/tree/master/_notebooks/results . Load and Clean the Data . Missing values: Retrieving from other datasets or through merging columns (or both) . The following will be done: . Active Cases: Retrieved from JHU dataset and calculating $active = pos-dead-recovered$ | Beds per State: Retrieved from External Datasets | . # TODO all_cases[&#39;active&#39;] = all_cases[&#39;positive&#39;] - all_cases[&#39;recovered&#39;] - all_cases[&#39;death&#39;] # change location of &#39;active&#39; column cols = list(all_cases) cols.insert(3, cols.pop(cols.index(&#39;active&#39;))) all_cases = all_cases.loc[:, cols] . # Load datasets for US population and Hospital beds per 1000 us_population = pd.read_csv(&#39;data/us_population.csv&#39;) hosp_beds = pd.read_csv(&#39;data/hospital_beds.csv&#39;) state_abbrev = pd.read_csv(&#39;data/us_state_names.csv&#39;) # add state abbreviations to us_population and hospital beds dataframe for state in state_abbrev[&#39;State&#39;].tolist(): # store state abbreviation in variable abbrev = state_abbrev.loc[state_abbrev[&#39;State&#39;] == state, &#39;Abbreviation&#39;].tolist()[0] # add abbrev to new column &#39;Abbreviation&#39; in us_population df us_population.loc[us_population[&#39;State&#39;] == state, &#39;Abbreviation&#39;] = abbrev # add abbrev to new column in hosp_beds df hosp_beds.loc[hosp_beds[&#39;Location&#39;] == state, &#39;Abbreviation&#39;] = abbrev # change order of columns of us_population cols = list(us_population) cols.insert(2, cols.pop(cols.index(&#39;Abbreviation&#39;))) us_population = us_population.loc[:, cols] # drop unnecessary columns of us_population us_population = us_population.drop(columns=[&#39;rank&#39;, &#39;Growth&#39;, &#39;Pop2018&#39;, &#39;Pop2010&#39;, &#39;growthSince2010&#39;, &#39;Percent&#39;, &#39;density&#39;]) # drop unnecessary columns of hosp_beds hosp_beds = hosp_beds.drop(columns=[&#39;Location&#39;, &#39;State/Local Government&#39;, &#39;Non-Profit&#39;, &#39;For-Profit&#39;]) # change order of columns of hosp_beds cols = list(hosp_beds) cols.insert(0, cols.pop(cols.index(&#39;Abbreviation&#39;))) hosp_beds = hosp_beds.loc[:, cols] . # filter out non-existing states like &#39;AS&#39; all_cases = all_cases[all_cases[&#39;state&#39;].isin(state_abbrev[&#39;Abbreviation&#39;].tolist())] . # Split dataframes by date df_split_by_date = dict(tuple(all_cases.groupby(&#39;date&#39;))) # Split dataframes by state df_split_by_state = dict(tuple(all_cases.groupby(&#39;state&#39;))) . # merge dataframes us_population and all_cases df_merge_uspop = all_cases.merge(us_population, how=&#39;left&#39;, left_on=&#39;state&#39;, right_on=&#39;Abbreviation&#39;) df_merge_uspop = df_merge_uspop.drop(columns=[&#39;Abbreviation&#39;]) df_merge_uspop = df_merge_uspop.rename(columns={&#39;Pop&#39;: &#39;population&#39;}) # change location of &#39;population&#39; column cols = list(df_merge_uspop) cols.insert(2, cols.pop(cols.index(&#39;population&#39;))) df_merge_uspop = df_merge_uspop.loc[:, cols] # merge dataframes hosp_beds and df_merge_uspop df_merge_hosp = df_merge_uspop.merge(hosp_beds, how=&#39;left&#39;, left_on=&#39;state&#39;, right_on=&#39;Abbreviation&#39;) df_merge_hosp = df_merge_hosp.drop(columns=[&#39;Abbreviation&#39;]) all_cases = df_merge_hosp.rename(columns={&#39;Total&#39;: &#39;bedsPerThousand&#39;}) . # Calculate the total beds, and add the column all_cases[&#39;total_beds&#39;] = all_cases[&#39;population&#39;] / 1000 * all_cases[&#39;bedsPerThousand&#39;] . # change abbreviations to state names all_cases = all_cases.rename(columns={&#39;state&#39;: &#39;abbrev&#39;}) all_cases = all_cases.rename(columns={&#39;State&#39;: &#39;state&#39;}) . # change location of &#39;state&#39; column cols = list(all_cases) cols.insert(1, cols.pop(cols.index(&#39;state&#39;))) all_cases = all_cases.loc[:, cols] . #print data frame head for spot visual data verification all_cases . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-27 | Alaska | AK | 734002 | 854.0 | 319.0 | 11.0 | NaN | NaN | 1.0 | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 2.2 | 1614.8044 | . 1 2020-06-27 | Alabama | AL | 4908621 | 35083.0 | 15298.0 | 655.0 | 2697.0 | NaN | NaN | ... | NaN | 34605.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.1 | 15216.7251 | . 2 2020-06-27 | Arkansas | AR | 3038999 | 18740.0 | 5707.0 | 284.0 | 1337.0 | NaN | 63.0 | ... | NaN | 18740.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.2 | 9724.7968 | . 3 2020-06-27 | Arizona | AZ | 7378494 | 70051.0 | 59813.0 | 2577.0 | 4595.0 | 657.0 | 433.0 | ... | NaN | 69641.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 14019.1386 | . 4 2020-06-27 | California | CA | 39937489 | 206433.0 | NaN | 5790.0 | NaN | 1562.0 | NaN | ... | NaN | 206433.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.8 | 71887.4802 | . 5 2020-06-27 | Colorado | CO | 5845526 | 31796.0 | 25693.0 | 226.0 | 5392.0 | NaN | NaN | ... | NaN | 28972.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 11106.4994 | . 6 2020-06-27 | Connecticut | CT | 3563077 | 46206.0 | 33842.0 | 106.0 | 10268.0 | NaN | NaN | ... | NaN | 44225.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.0 | 7126.1540 | . 7 2020-06-27 | District of Columbia | DC | 720687 | 10216.0 | 8474.0 | 136.0 | NaN | 43.0 | 26.0 | ... | NaN | 10216.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.4 | 3171.0228 | . 8 2020-06-27 | Delaware | DE | 982895 | 11091.0 | 3919.0 | 83.0 | NaN | 15.0 | NaN | ... | NaN | 10047.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.2 | 2162.3690 | . 9 2020-06-27 | Florida | FL | 21992985 | 132545.0 | NaN | NaN | 14432.0 | NaN | NaN | ... | 2010839.0 | 132545.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.6 | 57181.7610 | . 10 2020-06-27 | Georgia | GA | 10736059 | 74985.0 | NaN | 1178.0 | 10689.0 | NaN | NaN | ... | 721245.0 | 74985.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.4 | 25766.5416 | . 11 2020-06-27 | Hawaii | HI | 1412687 | 866.0 | 144.0 | NaN | 109.0 | NaN | NaN | ... | 85598.0 | 866.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 2684.1053 | . 12 2020-06-27 | Iowa | IA | 3179849 | 28012.0 | 9841.0 | 131.0 | NaN | 40.0 | 22.0 | ... | NaN | 28012.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.0 | 9539.5470 | . 13 2020-06-27 | Idaho | ID | 1826156 | 5148.0 | 1231.0 | NaN | 309.0 | NaN | NaN | ... | NaN | 4629.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 3469.6964 | . 14 2020-06-27 | Illinois | IL | 12659682 | 142130.0 | NaN | 1516.0 | NaN | 400.0 | 225.0 | ... | NaN | 141077.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 31649.2050 | . 15 2020-06-27 | Indiana | IN | 6745354 | 44575.0 | 8234.0 | 595.0 | 6982.0 | 257.0 | 82.0 | ... | NaN | 44575.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.7 | 18212.4558 | . 16 2020-06-27 | Kansas | KS | 2910357 | 13538.0 | 12495.0 | NaN | 1128.0 | NaN | NaN | ... | NaN | 13538.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 9604.1781 | . 17 2020-06-27 | Kentucky | KY | 4499692 | 14859.0 | 10576.0 | 387.0 | 2589.0 | 74.0 | NaN | ... | NaN | 14401.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.2 | 14399.0144 | . 18 2020-06-27 | Louisiana | LA | 4645184 | 54769.0 | 11787.0 | 700.0 | NaN | NaN | 73.0 | ... | NaN | 54769.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 15329.1072 | . 19 2020-06-27 | Massachusetts | MA | 6976597 | 108443.0 | NaN | 769.0 | 11310.0 | 143.0 | 90.0 | ... | NaN | 103376.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.3 | 16046.1731 | . 20 2020-06-27 | Maryland | MD | 6083116 | 66450.0 | 58358.0 | 478.0 | 10751.0 | 181.0 | NaN | ... | NaN | 66450.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 11557.9204 | . 21 2020-06-27 | Maine | ME | 1345790 | 3154.0 | 484.0 | 24.0 | 345.0 | 7.0 | 5.0 | ... | 87604.0 | 2809.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 3364.4750 | . 22 2020-06-27 | Michigan | MI | 10045029 | 69679.0 | 12427.0 | 557.0 | NaN | 193.0 | 106.0 | ... | 931142.0 | 63009.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 25112.5725 | . 23 2020-06-27 | Minnesota | MN | 5700671 | 35033.0 | 3180.0 | 300.0 | 3986.0 | 155.0 | NaN | ... | NaN | 35033.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 14251.6775 | . 24 2020-06-27 | Missouri | MO | 6169270 | 20261.0 | NaN | 680.0 | NaN | NaN | 66.0 | ... | 399926.0 | 20261.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.1 | 19124.7370 | . 25 2020-06-27 | Mississippi | MS | 2989260 | 25531.0 | 7254.0 | 731.0 | 3078.0 | 169.0 | 90.0 | ... | NaN | 25368.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.0 | 11957.0400 | . 26 2020-06-27 | Montana | MT | 1086759 | 852.0 | 226.0 | 9.0 | 95.0 | NaN | NaN | ... | NaN | 852.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 3586.3047 | . 27 2020-06-27 | North Carolina | NC | 10611862 | 60537.0 | 22304.0 | 888.0 | NaN | NaN | NaN | ... | NaN | 60537.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.1 | 22284.9102 | . 28 2020-06-27 | North Dakota | ND | 761723 | 3458.0 | 252.0 | 23.0 | 225.0 | NaN | NaN | ... | NaN | 3458.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.3 | 3275.4089 | . 29 2020-06-27 | Nebraska | NE | 1952570 | 18524.0 | 5560.0 | 125.0 | 1312.0 | NaN | NaN | ... | NaN | 18524.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.6 | 7029.2520 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 5851 2020-02-20 | Washington | WA | 7797095 | 82.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5852 2020-02-19 | Washington | WA | 7797095 | 69.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5853 2020-02-18 | Washington | WA | 7797095 | 59.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5854 2020-02-17 | Washington | WA | 7797095 | 50.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5855 2020-02-16 | Washington | WA | 7797095 | 35.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5856 2020-02-15 | Washington | WA | 7797095 | 28.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5857 2020-02-14 | Washington | WA | 7797095 | 21.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5858 2020-02-13 | Washington | WA | 7797095 | 18.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5859 2020-02-12 | Washington | WA | 7797095 | 18.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5860 2020-02-11 | Washington | WA | 7797095 | 17.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5861 2020-02-10 | Washington | WA | 7797095 | 16.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5862 2020-02-09 | Washington | WA | 7797095 | 13.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5863 2020-02-08 | Washington | WA | 7797095 | 13.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5864 2020-02-07 | Washington | WA | 7797095 | 12.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5865 2020-02-06 | Washington | WA | 7797095 | 11.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5866 2020-02-05 | Washington | WA | 7797095 | 8.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5867 2020-02-04 | Washington | WA | 7797095 | 8.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5868 2020-02-03 | Washington | WA | 7797095 | 7.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5869 2020-02-02 | Washington | WA | 7797095 | 6.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5870 2020-02-01 | Washington | WA | 7797095 | 4.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5871 2020-01-31 | Washington | WA | 7797095 | 3.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5872 2020-01-30 | Washington | WA | 7797095 | 3.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5873 2020-01-29 | Washington | WA | 7797095 | 3.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5874 2020-01-28 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5875 2020-01-27 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5876 2020-01-26 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5877 2020-01-25 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5878 2020-01-24 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5879 2020-01-23 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5880 2020-01-22 | Washington | WA | 7797095 | 2.0 | NaN | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5881 rows × 29 columns . Load and clean JHU data | Merge JHU dataset with main dataset | . # This cell takes some time, as it needs to connect to Kaggle Servers to retrieve data kaggle.api.authenticate() kaggle.api.dataset_download_files(&#39;benhamner/jhucovid19&#39;, path=&#39;./kaggle/input/jhucovid19/&#39;, unzip=True) . # Get Time-Series Data of cases as Pandas DataFrame dir_jhu = &#39;./kaggle/input/jhucovid19/csse_covid_19_data/csse_covid_19_daily_reports&#39; df_list = [] for dirname, _, files in os.walk(dir_jhu): for file in files: if &#39;gitignore&#39; not in file and &#39;README&#39; not in file: full_dir = os.path.join(dirname, file) df_list.append(pd.read_csv(full_dir)) jhu_df = pd.concat(df_list, axis=0, ignore_index=True, sort=True) # convert Last Update columns to datetime format jhu_df.loc[:, &#39;Last Update&#39;] = pd.to_datetime(jhu_df[&#39;Last Update&#39;]).apply(lambda x: x.date()) jhu_df.loc[:, &#39;Last_Update&#39;] = pd.to_datetime(jhu_df[&#39;Last_Update&#39;]).apply(lambda x: x.date()) # Combine Last Update with Last_Update jhu_df[&#39;LastUpdate&#39;] = jhu_df[&#39;Last_Update&#39;].combine_first(jhu_df[&#39;Last Update&#39;]) # Combine Country/Region with Country_Region jhu_df[&#39;CountryRegion&#39;] = jhu_df[&#39;Country/Region&#39;].combine_first(jhu_df[&#39;Country_Region&#39;]) # Retrieve only US data jhu_df = jhu_df[jhu_df[&#39;CountryRegion&#39;]==&#39;US&#39;] # Combine Province/State with Province_State jhu_df[&#39;ProvinceState&#39;] = jhu_df[&#39;Province/State&#39;].combine_first(jhu_df[&#39;Province_State&#39;]) # Drop unnecessary columns jhu_df = jhu_df.drop([&#39;Admin2&#39;, &#39;Lat&#39;, &#39;Latitude&#39;, &#39;Long_&#39;, &#39;Longitude&#39;, &#39;Combined_Key&#39;, &#39;Country/Region&#39;, &#39;Country_Region&#39;, &#39;Province/State&#39;, &#39;Province_State&#39;, &#39;Last Update&#39;, &#39;Last_Update&#39;, &#39;FIPS&#39;], axis=1) # Change column order cols = list(jhu_df) cols.insert(0, cols.pop(cols.index(&#39;CountryRegion&#39;))) cols.insert(1, cols.pop(cols.index(&#39;ProvinceState&#39;))) cols.insert(2, cols.pop(cols.index(&#39;LastUpdate&#39;))) jhu_df = jhu_df.loc[:, cols] # Change region to known US states state_abbrs_dict = {} for state in us.states.STATES: state_abbrs_dict[state.abbr] = state.name def toState(input_state, mapping): abbreviation = input_state.rstrip()[-2:] try: return_value = mapping[abbreviation] except KeyError: return_value = input_state return return_value jhu_df[&#39;ProvinceState&#39;] = jhu_df[&#39;ProvinceState&#39;].apply(lambda x: toState(x, state_abbrs_dict) if x != &#39;Washington, D.C.&#39; else &#39;District of Columbia&#39;) # Filter out unknown states jhu_df = jhu_df[jhu_df[&#39;ProvinceState&#39;].isin(all_cases.state.unique().tolist())] # Merge-sum rows with same date and State jhu_df = jhu_df.groupby([&#39;LastUpdate&#39;, &#39;ProvinceState&#39;]).agg( { &#39;Active&#39;: sum, &#39;Confirmed&#39;: sum, &#39;Deaths&#39;: sum, &#39;Recovered&#39;: sum } ).reset_index() jhu_df.tail() . LastUpdate ProvinceState Active Confirmed Deaths Recovered . 5190 2020-06-19 | Virginia | 54652.0 | 56238.0 | 1586.0 | 0.0 | . 5191 2020-06-19 | Washington | 25947.0 | 27192.0 | 1245.0 | 0.0 | . 5192 2020-06-19 | West Virginia | 2330.0 | 2418.0 | 88.0 | 0.0 | . 5193 2020-06-19 | Wisconsin | 23157.0 | 23876.0 | 719.0 | 0.0 | . 5194 2020-06-19 | Wyoming | 1126.0 | 1144.0 | 18.0 | 0.0 | . # Now that we have the JHU dataset relatively cleaned # we can go ahead and merge its data with our main dataset for i, row in all_cases.iterrows(): last_update = all_cases.at[i, &#39;date&#39;] state = all_cases.at[i, &#39;state&#39;] matching_row = jhu_df[jhu_df[&#39;ProvinceState&#39;] == state] matching_row = matching_row[matching_row[&#39;LastUpdate&#39;] == last_update].reset_index() if len(matching_row.values) &gt; 0: #all_cases.at[i, &#39;positive&#39;] = matching_row[&#39;Confirmed&#39;].values[0] all_cases.at[i, &#39;active&#39;] = matching_row[&#39;Active&#39;].values[0] #all_cases.at[i, &#39;recovered&#39;] = matching_row[&#39;Recovered&#39;].values[0] JHU was inconsistent, therefore removed #all_cases.at[i, &#39;death&#39;] = matching_row[&#39;Deaths&#39;].values[0] # Replace unknown recovery numbers with 0 if np.isnan(row[&#39;recovered&#39;]): all_cases.at[i, &#39;recovered&#39;] = 0 if all_cases.at[i, &#39;active&#39;] == 0 or np.isnan(row[&#39;active&#39;]): positive = all_cases.at[i, &#39;positive&#39;] recovered = all_cases.at[i, &#39;recovered&#39;] dead = all_cases.at[i, &#39;death&#39;] all_cases.at[i, &#39;active&#39;] = positive - recovered - dead #all_cases.tail() all_cases . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-27 | Alaska | AK | 734002 | 854.0 | 319.0 | 11.0 | NaN | NaN | 1.0 | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 2.2 | 1614.8044 | . 1 2020-06-27 | Alabama | AL | 4908621 | 35083.0 | 15298.0 | 655.0 | 2697.0 | NaN | NaN | ... | NaN | 34605.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.1 | 15216.7251 | . 2 2020-06-27 | Arkansas | AR | 3038999 | 18740.0 | 5707.0 | 284.0 | 1337.0 | NaN | 63.0 | ... | NaN | 18740.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.2 | 9724.7968 | . 3 2020-06-27 | Arizona | AZ | 7378494 | 70051.0 | 59813.0 | 2577.0 | 4595.0 | 657.0 | 433.0 | ... | NaN | 69641.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 14019.1386 | . 4 2020-06-27 | California | CA | 39937489 | 206433.0 | 200561.0 | 5790.0 | NaN | 1562.0 | NaN | ... | NaN | 206433.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.8 | 71887.4802 | . 5 2020-06-27 | Colorado | CO | 5845526 | 31796.0 | 25693.0 | 226.0 | 5392.0 | NaN | NaN | ... | NaN | 28972.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 11106.4994 | . 6 2020-06-27 | Connecticut | CT | 3563077 | 46206.0 | 33842.0 | 106.0 | 10268.0 | NaN | NaN | ... | NaN | 44225.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.0 | 7126.1540 | . 7 2020-06-27 | District of Columbia | DC | 720687 | 10216.0 | 8474.0 | 136.0 | NaN | 43.0 | 26.0 | ... | NaN | 10216.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.4 | 3171.0228 | . 8 2020-06-27 | Delaware | DE | 982895 | 11091.0 | 3919.0 | 83.0 | NaN | 15.0 | NaN | ... | NaN | 10047.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.2 | 2162.3690 | . 9 2020-06-27 | Florida | FL | 21992985 | 132545.0 | 129056.0 | NaN | 14432.0 | NaN | NaN | ... | 2010839.0 | 132545.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.6 | 57181.7610 | . 10 2020-06-27 | Georgia | GA | 10736059 | 74985.0 | 72209.0 | 1178.0 | 10689.0 | NaN | NaN | ... | 721245.0 | 74985.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.4 | 25766.5416 | . 11 2020-06-27 | Hawaii | HI | 1412687 | 866.0 | 144.0 | NaN | 109.0 | NaN | NaN | ... | 85598.0 | 866.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 2684.1053 | . 12 2020-06-27 | Iowa | IA | 3179849 | 28012.0 | 9841.0 | 131.0 | NaN | 40.0 | 22.0 | ... | NaN | 28012.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.0 | 9539.5470 | . 13 2020-06-27 | Idaho | ID | 1826156 | 5148.0 | 1231.0 | NaN | 309.0 | NaN | NaN | ... | NaN | 4629.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 3469.6964 | . 14 2020-06-27 | Illinois | IL | 12659682 | 142130.0 | 135056.0 | 1516.0 | NaN | 400.0 | 225.0 | ... | NaN | 141077.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 31649.2050 | . 15 2020-06-27 | Indiana | IN | 6745354 | 44575.0 | 8234.0 | 595.0 | 6982.0 | 257.0 | 82.0 | ... | NaN | 44575.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.7 | 18212.4558 | . 16 2020-06-27 | Kansas | KS | 2910357 | 13538.0 | 12495.0 | NaN | 1128.0 | NaN | NaN | ... | NaN | 13538.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 9604.1781 | . 17 2020-06-27 | Kentucky | KY | 4499692 | 14859.0 | 10576.0 | 387.0 | 2589.0 | 74.0 | NaN | ... | NaN | 14401.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.2 | 14399.0144 | . 18 2020-06-27 | Louisiana | LA | 4645184 | 54769.0 | 11787.0 | 700.0 | NaN | NaN | 73.0 | ... | NaN | 54769.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 15329.1072 | . 19 2020-06-27 | Massachusetts | MA | 6976597 | 108443.0 | 100402.0 | 769.0 | 11310.0 | 143.0 | 90.0 | ... | NaN | 103376.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.3 | 16046.1731 | . 20 2020-06-27 | Maryland | MD | 6083116 | 66450.0 | 58358.0 | 478.0 | 10751.0 | 181.0 | NaN | ... | NaN | 66450.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 11557.9204 | . 21 2020-06-27 | Maine | ME | 1345790 | 3154.0 | 484.0 | 24.0 | 345.0 | 7.0 | 5.0 | ... | 87604.0 | 2809.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 3364.4750 | . 22 2020-06-27 | Michigan | MI | 10045029 | 69679.0 | 12427.0 | 557.0 | NaN | 193.0 | 106.0 | ... | 931142.0 | 63009.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 25112.5725 | . 23 2020-06-27 | Minnesota | MN | 5700671 | 35033.0 | 3180.0 | 300.0 | 3986.0 | 155.0 | NaN | ... | NaN | 35033.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.5 | 14251.6775 | . 24 2020-06-27 | Missouri | MO | 6169270 | 20261.0 | 19265.0 | 680.0 | NaN | NaN | 66.0 | ... | 399926.0 | 20261.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.1 | 19124.7370 | . 25 2020-06-27 | Mississippi | MS | 2989260 | 25531.0 | 7254.0 | 731.0 | 3078.0 | 169.0 | 90.0 | ... | NaN | 25368.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.0 | 11957.0400 | . 26 2020-06-27 | Montana | MT | 1086759 | 852.0 | 226.0 | 9.0 | 95.0 | NaN | NaN | ... | NaN | 852.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.3 | 3586.3047 | . 27 2020-06-27 | North Carolina | NC | 10611862 | 60537.0 | 22304.0 | 888.0 | NaN | NaN | NaN | ... | NaN | 60537.0 | 0 | 0 | 0 | 0 | 0 | NaN | 2.1 | 22284.9102 | . 28 2020-06-27 | North Dakota | ND | 761723 | 3458.0 | 252.0 | 23.0 | 225.0 | NaN | NaN | ... | NaN | 3458.0 | 0 | 0 | 0 | 0 | 0 | NaN | 4.3 | 3275.4089 | . 29 2020-06-27 | Nebraska | NE | 1952570 | 18524.0 | 5560.0 | 125.0 | 1312.0 | NaN | NaN | ... | NaN | 18524.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.6 | 7029.2520 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 5851 2020-02-20 | Washington | WA | 7797095 | 82.0 | 82.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5852 2020-02-19 | Washington | WA | 7797095 | 69.0 | 69.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5853 2020-02-18 | Washington | WA | 7797095 | 59.0 | 59.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5854 2020-02-17 | Washington | WA | 7797095 | 50.0 | 50.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5855 2020-02-16 | Washington | WA | 7797095 | 35.0 | 35.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5856 2020-02-15 | Washington | WA | 7797095 | 28.0 | 28.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5857 2020-02-14 | Washington | WA | 7797095 | 21.0 | 21.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5858 2020-02-13 | Washington | WA | 7797095 | 18.0 | 18.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5859 2020-02-12 | Washington | WA | 7797095 | 18.0 | 18.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5860 2020-02-11 | Washington | WA | 7797095 | 17.0 | 17.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5861 2020-02-10 | Washington | WA | 7797095 | 16.0 | 16.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5862 2020-02-09 | Washington | WA | 7797095 | 13.0 | 13.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5863 2020-02-08 | Washington | WA | 7797095 | 13.0 | 13.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5864 2020-02-07 | Washington | WA | 7797095 | 12.0 | 12.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5865 2020-02-06 | Washington | WA | 7797095 | 11.0 | 11.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5866 2020-02-05 | Washington | WA | 7797095 | 8.0 | 8.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5867 2020-02-04 | Washington | WA | 7797095 | 8.0 | 8.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5868 2020-02-03 | Washington | WA | 7797095 | 7.0 | 7.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5869 2020-02-02 | Washington | WA | 7797095 | 6.0 | 6.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5870 2020-02-01 | Washington | WA | 7797095 | 4.0 | 4.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5871 2020-01-31 | Washington | WA | 7797095 | 3.0 | 3.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5872 2020-01-30 | Washington | WA | 7797095 | 3.0 | 3.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5873 2020-01-29 | Washington | WA | 7797095 | 3.0 | 3.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5874 2020-01-28 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5875 2020-01-27 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5876 2020-01-26 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5877 2020-01-25 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5878 2020-01-24 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5879 2020-01-23 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5880 2020-01-22 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5881 rows × 29 columns . # Save formatted dataset offline in case of disaster dataset_file = &#39;results/all_cases.csv&#39; all_cases.to_csv(dataset_file) . # convert date to datetime format all_cases[&#39;date&#39;] = pd.to_datetime(all_cases[&#39;date&#39;]) . An Exploratory data analysis of the US dataset . Basic triad of the dataset: validating data types and data integrity of each row . dataset_file = &#39;results/all_cases.csv&#39; covid_df = pd.read_csv(dataset_file, index_col=0) # convert date to datetime format covid_df[&#39;date&#39;] = pd.to_datetime(covid_df[&#39;date&#39;]) covid_df.info() # set float format to 3 decimals pd.set_option(&#39;display.float_format&#39;, lambda x: &#39;%.3f&#39; % x) . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 5881 entries, 0 to 5880 Data columns (total 29 columns): date 5881 non-null datetime64[ns] state 5881 non-null object abbrev 5881 non-null object population 5881 non-null int64 positive 5881 non-null float64 active 5881 non-null float64 hospitalizedCurrently 3598 non-null float64 hospitalizedCumulative 3198 non-null float64 inIcuCurrently 1858 non-null float64 onVentilatorCurrently 1653 non-null float64 recovered 5881 non-null float64 dataQualityGrade 4947 non-null object lastUpdateEt 5526 non-null object dateModified 5526 non-null object checkTimeEt 5526 non-null object death 5881 non-null float64 hospitalized 3198 non-null float64 totalTestsViral 1568 non-null float64 positiveTestsViral 525 non-null float64 negativeTestsViral 524 non-null float64 positiveCasesViral 3059 non-null float64 commercialScore 5881 non-null int64 negativeRegularScore 5881 non-null int64 negativeScore 5881 non-null int64 positiveScore 5881 non-null int64 score 5881 non-null int64 grade 0 non-null float64 bedsPerThousand 5881 non-null float64 total_beds 5881 non-null float64 dtypes: datetime64[ns](1), float64(16), int64(6), object(6) memory usage: 1.3+ MB . covid_df.head() . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-27 | Alaska | AK | 734002 | 854.000 | 319.000 | 11.000 | nan | nan | 1.000 | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 2.200 | 1614.804 | . 1 2020-06-27 | Alabama | AL | 4908621 | 35083.000 | 15298.000 | 655.000 | 2697.000 | nan | nan | ... | nan | 34605.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.100 | 15216.725 | . 2 2020-06-27 | Arkansas | AR | 3038999 | 18740.000 | 5707.000 | 284.000 | 1337.000 | nan | 63.000 | ... | nan | 18740.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.200 | 9724.797 | . 3 2020-06-27 | Arizona | AZ | 7378494 | 70051.000 | 59813.000 | 2577.000 | 4595.000 | 657.000 | 433.000 | ... | nan | 69641.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 14019.139 | . 4 2020-06-27 | California | CA | 39937489 | 206433.000 | 200561.000 | 5790.000 | nan | 1562.000 | nan | ... | nan | 206433.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.800 | 71887.480 | . 5 rows × 29 columns . The NaN values may indicate that there were no to few Covid-19 patients at these date points. We further analyse the statistical values of the dataset columns to ensure data integrity and accuracy. . covid_df.describe() # TODO rounding up the numbers . population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently recovered death hospitalized ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . count 5881.000 | 5881.000 | 5881.000 | 3598.000 | 3198.000 | 1858.000 | 1653.000 | 5881.000 | 5881.000 | 3198.000 | ... | 524.000 | 3059.000 | 5881.000 | 5881.000 | 5881.000 | 5881.000 | 5881.000 | 0.000 | 5881.000 | 5881.000 | . mean 6543367.585 | 20916.359 | 18615.094 | 1028.274 | 4343.898 | 444.164 | 226.540 | 4396.344 | 1091.030 | 4343.898 | ... | 288695.632 | 31980.345 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 2.625 | 15806.903 | . std 7387134.109 | 46506.152 | 41859.038 | 1934.647 | 12924.575 | 695.599 | 330.534 | 10915.396 | 2906.033 | 12924.575 | ... | 383203.556 | 56469.631 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 0.744 | 16159.795 | . min 567025.000 | 0.000 | 0.000 | 1.000 | 0.000 | 2.000 | 0.000 | 0.000 | 0.000 | 0.000 | ... | 17.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 1.600 | 1318.928 | . 25% 1778070.000 | 631.000 | 543.000 | 121.000 | 219.250 | 82.000 | 36.000 | 0.000 | 12.000 | 219.250 | ... | 49528.250 | 5009.500 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 2.100 | 3773.952 | . 50% 4499692.000 | 5025.000 | 4494.000 | 402.000 | 954.000 | 185.500 | 94.000 | 206.000 | 144.000 | 954.000 | ... | 138808.000 | 13637.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 2.500 | 11557.920 | . 75% 7797095.000 | 20595.000 | 17382.000 | 1037.750 | 3215.750 | 487.000 | 250.000 | 3064.000 | 772.000 | 3215.750 | ... | 354942.750 | 35269.500 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 3.100 | 19124.737 | . max 39937489.000 | 391923.000 | 356899.000 | 18825.000 | 89995.000 | 5225.000 | 2425.000 | 78248.000 | 24830.000 | 89995.000 | ... | 2010839.000 | 391923.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 4.800 | 71887.480 | . 8 rows × 22 columns . # drop unnecessary columns covid_cleaned = covid_df.drop([&#39;hospitalized&#39;, &#39;bedsPerThousand&#39;], axis=1) covid_100k = covid_cleaned.copy() # list of columns to transform to per 100k columns_list = [&#39;positive&#39;, &#39;active&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;onVentilatorCurrently&#39;, &#39;total_beds&#39;, &#39;totalTestsViral&#39;] # add columns per 100k for column in columns_list: if column == &#39;total_beds&#39;: covid_100k[&#39;BedsPer100k&#39;.format(column)] = (covid_cleaned.loc[:, column] / covid_cleaned.loc[:, &#39;population&#39;]) * 100000 else: covid_100k[&#39;{}_100k&#39;.format(column)] = (covid_cleaned.loc[:, column] / covid_cleaned.loc[:, &#39;population&#39;]) * 100000 covid_100k = covid_100k.drop(columns_list, axis=1) . covid_100k[&#39;date&#39;] = pd.to_datetime(covid_100k[&#39;date&#39;]) start_date = &#39;2020-04-18&#39; end_date = &#39;2020-05-19&#39; mask = (covid_100k[&#39;date&#39;] &gt; start_date) &amp; (covid_100k[&#39;date&#39;] &lt;= end_date) covid_100k_last_month = covid_100k.loc[mask] . covid_100k_last_month_part1 = covid_100k_last_month.groupby(&#39;date&#39;).sum().loc[:, [&#39;positive_100k&#39;,&#39;active_100k&#39;,&#39;recovered_100k&#39;,&#39;death_100k&#39;,&#39;hospitalizedCumulative_100k&#39;]].diff(periods=1, axis=0) covid_100k_last_month_part2 = covid_100k_last_month.groupby(&#39;date&#39;).sum().loc[:, [&#39;inIcuCurrently_100k&#39;,&#39;onVentilatorCurrently_100k&#39;,&#39;BedsPer100k&#39;]] final_100k_last_month = covid_100k_last_month_part1.merge(covid_100k_last_month_part2, left_index=True, right_index=True) . final_100k_last_month.head() . positive_100k active_100k recovered_100k death_100k hospitalizedCumulative_100k inIcuCurrently_100k onVentilatorCurrently_100k BedsPer100k . date . 2020-04-19 nan | nan | nan | nan | nan | 153.528 | 80.717 | 13440.000 | . 2020-04-20 413.759 | 391.692 | 35.481 | 25.728 | 22.652 | 156.581 | 79.710 | 13440.000 | . 2020-04-21 387.394 | 360.446 | 65.218 | 30.520 | 31.446 | 166.081 | 78.603 | 13440.000 | . 2020-04-22 428.601 | 989.954 | 412.625 | 28.780 | 36.181 | 167.561 | 78.032 | 13440.000 | . 2020-04-23 452.031 | -2213.482 | 72.921 | 26.282 | 28.842 | 166.277 | 94.521 | 13440.000 | . final_100k_last_month.describe() . positive_100k active_100k recovered_100k death_100k hospitalizedCumulative_100k inIcuCurrently_100k onVentilatorCurrently_100k BedsPer100k . count 30.000 | 30.000 | 30.000 | 30.000 | 30.000 | 31.000 | 31.000 | 31.000 | . mean 399.188 | 364.943 | 147.172 | 23.271 | 39.160 | 134.117 | 73.503 | 13440.000 | . std 58.939 | 634.169 | 81.341 | 5.781 | 43.524 | 19.860 | 8.141 | 0.000 | . min 287.019 | -2213.482 | 35.481 | 13.315 | 9.507 | 109.602 | 61.622 | 13440.000 | . 25% 348.980 | 314.204 | 80.563 | 18.439 | 22.991 | 118.222 | 66.261 | 13440.000 | . 50% 405.026 | 366.234 | 127.774 | 24.119 | 28.295 | 127.613 | 74.706 | 13440.000 | . 75% 432.647 | 419.664 | 212.491 | 26.201 | 32.754 | 149.768 | 79.157 | 13440.000 | . max 544.349 | 2291.210 | 412.625 | 33.917 | 246.371 | 167.561 | 94.521 | 13440.000 | . # save description cleaned dataset to csv describe_file = &#39;results/final_100k_last_month.csv&#39; final_100k_last_month.describe().to_csv(describe_file) . Graphical Exploratory Analysis . Plotting histograms, scatterplots and boxplots to assess the distribution of the entire US dataset. . # Omitting the categorical (states/abbreviations) and time columns # There must be an easier way for you, but this was the easiest way I could think of covid_cleaned[&#39;date&#39;] = pd.to_datetime(covid_cleaned[&#39;date&#39;]) # mask data for last month start_date = &#39;2020-04-18&#39; end_date = &#39;2020-05-19&#39; mask = (covid_cleaned[&#39;date&#39;] &gt; start_date) &amp; (covid_cleaned[&#39;date&#39;] &lt;= end_date) covid_cleaned_last_month = covid_cleaned.loc[mask] plot_df = covid_cleaned_last_month[[&#39;population&#39;, &#39;active&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;onVentilatorCurrently&#39;, &#39;total_beds&#39;]] plot_df_last_month = covid_100k_last_month[[&#39;population&#39;, &#39;active_100k&#39;, &#39;recovered_100k&#39;, &#39;death_100k&#39;, &#39;hospitalizedCurrently_100k&#39;, &#39;inIcuCurrently_100k&#39;, &#39;onVentilatorCurrently_100k&#39;, &#39;BedsPer100k&#39;]] . timeseries_usa_df = covid_100k.loc[:, [&#39;date&#39;, &#39;positive_100k&#39;, &#39;active_100k&#39;, &#39;recovered_100k&#39;, &#39;death_100k&#39;, &#39;hospitalizedCurrently_100k&#39;, &#39;inIcuCurrently_100k&#39;, &#39;onVentilatorCurrently_100k&#39;, &#39;BedsPer100k&#39;]].groupby(&#39;date&#39;).sum().reset_index() # timeseries_usa_df[&#39;log_positive&#39;] = np.log(timeseries_usa_df[&#39;positive_100k&#39;]) # timeseries_usa_df[&#39;log_active&#39;] = np.log(timeseries_usa_df[&#39;active_100k&#39;]) # timeseries_usa_df[&#39;log_recovered&#39;] = np.log(timeseries_usa_df[&#39;recovered_100k&#39;]) # timeseries_usa_df[&#39;log_death&#39;] = np.log(timeseries_usa_df[&#39;death_100k&#39;]) . timeseries_usa_df.tail() . date positive_100k active_100k recovered_100k death_100k hospitalizedCurrently_100k inIcuCurrently_100k onVentilatorCurrently_100k BedsPer100k . 153 2020-06-23 | 32860.514 | 19133.883 | 12183.722 | 1542.909 | 403.069 | 71.078 | 37.684 | 13440.000 | . 154 2020-06-24 | 33315.285 | 19401.954 | 12359.391 | 1553.940 | 408.570 | 68.612 | 36.820 | 13440.000 | . 155 2020-06-25 | 33812.912 | 19730.969 | 12498.864 | 1583.079 | 414.087 | 67.864 | 36.962 | 13440.000 | . 156 2020-06-26 | 34335.924 | 20098.997 | 12643.998 | 1592.929 | 404.115 | 67.051 | 34.318 | 13440.000 | . 157 2020-06-27 | 34829.638 | 20417.559 | 12812.241 | 1599.839 | 407.257 | 68.533 | 35.118 | 13440.000 | . covid_df.head() . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-27 | Alaska | AK | 734002 | 854.000 | 319.000 | 11.000 | nan | nan | 1.000 | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 2.200 | 1614.804 | . 1 2020-06-27 | Alabama | AL | 4908621 | 35083.000 | 15298.000 | 655.000 | 2697.000 | nan | nan | ... | nan | 34605.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.100 | 15216.725 | . 2 2020-06-27 | Arkansas | AR | 3038999 | 18740.000 | 5707.000 | 284.000 | 1337.000 | nan | 63.000 | ... | nan | 18740.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.200 | 9724.797 | . 3 2020-06-27 | Arizona | AZ | 7378494 | 70051.000 | 59813.000 | 2577.000 | 4595.000 | 657.000 | 433.000 | ... | nan | 69641.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 14019.139 | . 4 2020-06-27 | California | CA | 39937489 | 206433.000 | 200561.000 | 5790.000 | nan | 1562.000 | nan | ... | nan | 206433.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.800 | 71887.480 | . 5 rows × 29 columns . # get data from last day # plot_df_last_date = plot_df.loc[covid_df[&#39;date&#39;] == &#39;2020-05-18&#39;] # Plotting histograms to gain insight of the distribution shape, skewness and scale fig, axs = plt.subplots(4,2,figsize = (16, 16)) sns.set() for i, column in enumerate(plot_df_last_month.columns): if (i + 1) % 2 == 0: ax = axs[(i//2), 1] else: ax = axs[(i//2), 0] sns.distplot(plot_df_last_month[column], fit=norm, fit_kws=dict(label=&#39;normality&#39;), hist_kws=dict(color=&#39;plum&#39;, edgecolor=&#39;k&#39;, linewidth=1, label=&#39;frequency&#39;), ax=ax, color=&#39;#9d53ad&#39;) ax.legend(loc=&#39;upper right&#39;) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Looking at linearity and variance with scatterplots # Removing the target variable and saving it in another df target = plot_df.hospitalizedCurrently indep_var = plot_df.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var.columns): ax=fig.add_subplot(4, 3, i+1) sns.regplot(x=indep_var[col], y=target, data=indep_var, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;, &#39;label&#39;: &#39;hospitCurr&#39;}) plt.suptitle(&#39;Scatterplots with Target Hospitalized Patients Showing Growth Trajectories&#39;, fontsize=18) plt.legend() plt.tight_layout() fig.subplots_adjust(top=0.95) . # Assessing the normality of the distribution with a boxplot # Boxplot with removed outliers fig, ax = plt.subplots(figsize = (16, 12)) for i, col in enumerate(plot_df.columns): ax=fig.add_subplot(4, 3, i+1) sns.boxplot(x=plot_df[col], data=plot_df, color=&#39;lightblue&#39;, showfliers=False) plt.suptitle(&#39;Boxplots of Independent Variables&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . # get data from last day plot_df_last_date = plot_df.loc[covid_df[&#39;date&#39;] == &#39;2020-05-18&#39;] fig, ax = plt.subplots(figsize = (16, 12)) for i, col in enumerate(plot_df_last_date.columns): ax=fig.add_subplot(4, 3, i+1) sns.boxplot(x=plot_df_last_date[col], data=plot_df, color=&#39;lightblue&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . Analysis of Hospitalizations, ICU Hospitilizations, Active Cases, New Cases, Deaths, and Recoveries by State . Since the normality of the independent variables is highly variable do to temporal and precision differences from each state, we further assess each state&#39;s data by viewing trends on the independent variables in both scatter and box-and-whisker plots. . New York . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . C: Users Doctor Gomez AppData Roaming Python Python37 site-packages pandas plotting _converter.py:129: FutureWarning: Using an implicitly registered datetime converter for a matplotlib plotting method. The converter was registered by pandas on import. Future versions of pandas will require you to explicitly register matplotlib converters. To register the converters: &gt;&gt;&gt; from pandas.plotting import register_matplotlib_converters &gt;&gt;&gt; register_matplotlib_converters() . Text(0, 0.5, &#39;No. Patients&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.inIcuCurrently, linewidth=3.3) plt.title(&#39;Number of Active ICU Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.onVentilatorCurrently, linewidth=3.3) plt.title(&#39;Number of Active Ventilator Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCumulative, linewidth=3.3) plt.title(&#39;Number of Cumulative Hospitilizations in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.positive, linewidth=3.3) plt.title(&#39;Number of Cumulative Positive Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) . Text(0, 0.5, &#39;No. Postives&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.recovered, linewidth=3.3) plt.title(&#39;Number of Cummulative Recovered Cases in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Victims&#39;) . Text(0, 0.5, &#39;No. Victims&#39;) . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.death, linewidth=3.3) plt.title(&#39;Number of Cumulative Deaths in NY&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Postives&#39;) # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###ENDNEWYORK . California: . cali = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;CA&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;California&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(cali.date, cali.hospitalizedCurrently) plt.title(&#39;Number of Patients in CA Currently Hospitalized&#39;) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values cali[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] cali.head() # Omit the NaN cols cali = cali[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots CA # Split dependent var from independent variables target_ca = cali.hospitalizedCurrently indep_var_ca = cali.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ca.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_ca[col], y=target_ca, data=indep_var_ca, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables CA&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of CA fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(cali.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=cali[col], data=cali, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables CA&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endcali . Texas: . texas = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;TX&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Texas&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(texas.date, texas.hospitalizedCurrently) plt.title(&#39;Number of Patients in TX Currently Hospitalized&#39;) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values texas[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] texas.head() # Omit the NaN cols texas = texas[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots TX # Split dependent var from independent variables target_tx = texas.hospitalizedCurrently indep_var_tx = texas.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_tx.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_tx[col], y=target_tx, data=indep_var_tx, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables TX&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of TX fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(texas.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=texas[col], data=texas, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables TX&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endtx . South Carolina: . sc = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;SC&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;South Carolina&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(sc.date, sc.hospitalizedCurrently) plt.title(&#39;Number of Patients in SC Currently Hospitalized&#39;) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values sc[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] sc.head() # Omit the NaN cols sc = sc[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots SC # Split dependent var from independent variables target_sc = sc.hospitalizedCurrently indep_var_sc = sc.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_sc.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_sc[col], y=target_sc, data=indep_var_sc, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables SC&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of SC fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(sc.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=sc[col], data=sc, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables TX&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endsouthcarolina . Nevada: . nevada = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;NV&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Nevada&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(nevada.date, nevada.hospitalizedCurrently) plt.title(&#39;Number of Patients in NV Currently Hospitalized&#39;) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values nevada[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] nevada.head() # Omit the NaN cols nevada = nevada[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots NV # Split dependent var from independent variables target_nv = nevada.hospitalizedCurrently indep_var_nv = nevada.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_nv.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_nv[col], y=target_nv, data=indep_var_nv, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NV&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NV fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(nevada.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=nevada[col], data=nevada, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NV&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endnevada . Arizona: . arizona = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;AZ&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Arizona&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(arizona.date, arizona.hospitalizedCurrently, linewidth=5) plt.title(&#39;Number of Patients in AZ Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values arizona[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] arizona.head() # Omit the NaN cols arizona = arizona[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots AZ # Split dependent var from independent variables target_az = arizona.hospitalizedCurrently indep_var_az = arizona.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_az.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_az[col], y=target_az, data=indep_var_az, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables AZ&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of AZ fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(arizona.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=arizona[col], data=arizona, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables AZ&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endarizona . Mississippi: . mississippi = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;MS&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Mississippi&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(mississippi.date, mississippi.hospitalizedCurrently) plt.title(&#39;Number of Patients in MS Currently Hospitalized&#39;) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values mississippi[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] mississippi.head() # Omit the NaN cols mississippi = mississippi[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots MS # Split dependent var from independent variables target_ms = texas.hospitalizedCurrently indep_var_ms = texas.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ms.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_ms[col], y=target_ms, data=indep_var_ms, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables MS&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of MS fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(texas.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=mississippi[col], data=mississippi, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables MS&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endmississippi . Utah: . utah = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;UT&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Utah&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(utah.date, utah.hospitalizedCurrently) plt.title(&#39;Number of Patients in UT Currently Hospitalized&#39;) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values utah[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] utah.head() # Omit the NaN cols utah = utah[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots UT # Split dependent var from independent variables target_ut = utah.hospitalizedCurrently indep_var_ut = utah.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_tx.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_ut[col], y=target_ut, data=indep_var_ut, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables UT&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endutah . Georgia: . georgia = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;GA&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Georgia&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(georgia.date, georgia.hospitalizedCurrently) plt.title(&#39;Number of Patients in GA Currently Hospitalized&#39;) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values georgia[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] georgia.head() # Omit the NaN cols georgia = georgia[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots GA # Split dependent var from independent variables target_ga = georgia.hospitalizedCurrently indep_var_ga = georgia.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ga.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_ga[col], y=target_ga, data=indep_var_ga, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables TX&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of GA fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(georgia.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=georgia[col], data=georgia, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables GA&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endgeorgia . Alabama: . bama = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;AL&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Alabama&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(bama.date, bama.hospitalizedCurrently) plt.title(&#39;Number of Patients in AL Currently Hospitalized&#39;) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values bama[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] bama.head() # Omit the NaN cols bama = bama[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots AL # Split dependent var from independent variables target_al = bama.hospitalizedCurrently indep_var_al = bama.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_al.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_al[col], y=target_al, data=indep_var_al, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables AL&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of AL fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(bama.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=bama[col], data=bama, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables TX&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endalabama . Oklahoma: . oklahoma = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;OK&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Oklahoma&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(oklahoma.date, oklahoma.hospitalizedCurrently) plt.title(&#39;Number of Patients in OK Currently Hospitalized&#39;) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(oklahoma.date, oklahoma.totalTestsViral) plt.title(&#39;Number of Patients in OK Currently Hospitalized&#39;) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values oklahoma[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;, &#39;totalTestsViral&#39;]] oklahoma.head() # Omit the NaN cols oklahoma = oklahoma[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;totalTestsViral&#39;]] . # Scatter plots OK # Split dependent var from independent variables target_ok = oklahoma.hospitalizedCurrently indep_var_ok = oklahoma.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ok.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_ok[col], y=target_ok, data=indep_var_ok, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables OK&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of OK fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(oklahoma.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=oklahoma[col], data=oklahoma, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables OK&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endoklahoma . ###ENDSTATES . Assessing Correlation of Independent Variables . # TODO add some explanation / look more into collinear variables . # Heatmap of correlations # Save correlations to variable corr = covid_cleaned.corr(method=&#39;pearson&#39;) # We can create a mask to not show duplicate values mask = np.triu(np.ones_like(corr, dtype=np.bool)) # Set up the matplotlib figure fig, ax = plt.subplots(figsize=(16,16)) # Generate heatmap sns.heatmap(corr, annot=True, mask=mask, cmap=&#39;GnBu&#39;, center=0, square=True, linewidths=.5, cbar_kws={&quot;shrink&quot;: .5}) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x16e5ac4e908&gt; . Build model for dependent Variable . To be used to predict current hospitalizations | Having more complete variables for in ICU currently and on Ventilator Currently will allow us to predict these numbers as well. | . # We compare three models: # - Polynomial Regression # - Linear Regression # - ElasticNet # Copy DFs to not mess up original one # We will use model_df for our regression model model_df = all_cases.copy() # Delete redundant rows for row in [&#39;abbrev&#39;, &#39;bedsPerThousand&#39;, &#39;hospitalized&#39;, &#39;state&#39;, &#39;hospitalizedCumulative&#39;, &#39;dataQualityGrade&#39;, &#39;lastUpdateEt&#39;]: del model_df[row] # Drop NaN values for hospitalizedCurrently model_df = model_df.dropna(subset=[&#39;hospitalizedCurrently&#39;]) # Drop Values with abnormal active-hospitalised ratios (outside Conf. Interval) model_df[&#39;ratio_hospital&#39;] = model_df[&#39;hospitalizedCurrently&#39;] / model_df[&#39;active&#39;] model_df = model_df[~(model_df[&#39;ratio_hospital&#39;] &gt;= model_df.ratio_hospital.quantile(0.99))] #model_df = model_df[~(model_df[&#39;ratio_hospital&#39;] &lt;= model_df[&#39;ratio_hospital&#39;].median())] del model_df[&#39;ratio_hospital&#39;] # Get peek of model to use model_df.describe() . population positive active hospitalizedCurrently inIcuCurrently onVentilatorCurrently recovered death totalTestsViral positiveTestsViral negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade total_beds . count 3562.000 | 3562.000 | 3562.000 | 3562.000 | 1809.000 | 1606.000 | 3562.000 | 3562.000 | 1100.000 | 391.000 | 390.000 | 2486.000 | 3562.000 | 3562.000 | 3562.000 | 3562.000 | 3562.000 | 0.000 | 3562.000 | . mean 6738367.173 | 31598.061 | 27926.641 | 1024.725 | 440.929 | 223.639 | 6908.870 | 1706.631 | 395184.981 | 25193.292 | 239433.431 | 36358.513 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 16013.196 | . std 7743293.297 | 56556.886 | 50952.935 | 1938.260 | 701.297 | 332.946 | 13332.619 | 3587.151 | 532521.958 | 26029.658 | 228868.150 | 61121.853 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 16519.227 | . min 567025.000 | 115.000 | 113.000 | 1.000 | 2.000 | 0.000 | 0.000 | 0.000 | 9055.000 | 407.000 | 8648.000 | 396.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 1318.928 | . 25% 1778070.000 | 3242.000 | 2827.250 | 117.250 | 81.000 | 34.250 | 0.000 | 90.000 | 86677.750 | 4128.000 | 62733.000 | 6399.750 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 3773.952 | . 50% 4645184.000 | 12139.500 | 10043.000 | 401.500 | 181.000 | 91.000 | 1268.500 | 470.000 | 217376.500 | 14046.000 | 168871.000 | 16292.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 11557.920 | . 75% 8626207.000 | 35012.250 | 29934.250 | 1030.250 | 471.000 | 240.000 | 6250.750 | 1585.250 | 479986.000 | 43919.500 | 295648.000 | 40458.500 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 19124.737 | . max 39937489.000 | 391923.000 | 356899.000 | 18825.000 | 5225.000 | 2425.000 | 78248.000 | 24830.000 | 3862310.000 | 86713.000 | 931142.000 | 391923.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 71887.480 | . #Printing data for visual verification. all_cases . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-27 | Alaska | AK | 734002 | 854.000 | 319.000 | 11.000 | nan | nan | 1.000 | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 2.200 | 1614.804 | . 1 2020-06-27 | Alabama | AL | 4908621 | 35083.000 | 15298.000 | 655.000 | 2697.000 | nan | nan | ... | nan | 34605.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.100 | 15216.725 | . 2 2020-06-27 | Arkansas | AR | 3038999 | 18740.000 | 5707.000 | 284.000 | 1337.000 | nan | 63.000 | ... | nan | 18740.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.200 | 9724.797 | . 3 2020-06-27 | Arizona | AZ | 7378494 | 70051.000 | 59813.000 | 2577.000 | 4595.000 | 657.000 | 433.000 | ... | nan | 69641.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 14019.139 | . 4 2020-06-27 | California | CA | 39937489 | 206433.000 | 200561.000 | 5790.000 | nan | 1562.000 | nan | ... | nan | 206433.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.800 | 71887.480 | . 5 2020-06-27 | Colorado | CO | 5845526 | 31796.000 | 25693.000 | 226.000 | 5392.000 | nan | nan | ... | nan | 28972.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 11106.499 | . 6 2020-06-27 | Connecticut | CT | 3563077 | 46206.000 | 33842.000 | 106.000 | 10268.000 | nan | nan | ... | nan | 44225.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.000 | 7126.154 | . 7 2020-06-27 | District of Columbia | DC | 720687 | 10216.000 | 8474.000 | 136.000 | nan | 43.000 | 26.000 | ... | nan | 10216.000 | 0 | 0 | 0 | 0 | 0 | nan | 4.400 | 3171.023 | . 8 2020-06-27 | Delaware | DE | 982895 | 11091.000 | 3919.000 | 83.000 | nan | 15.000 | nan | ... | nan | 10047.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.200 | 2162.369 | . 9 2020-06-27 | Florida | FL | 21992985 | 132545.000 | 129056.000 | nan | 14432.000 | nan | nan | ... | 2010839.000 | 132545.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.600 | 57181.761 | . 10 2020-06-27 | Georgia | GA | 10736059 | 74985.000 | 72209.000 | 1178.000 | 10689.000 | nan | nan | ... | 721245.000 | 74985.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.400 | 25766.542 | . 11 2020-06-27 | Hawaii | HI | 1412687 | 866.000 | 144.000 | nan | 109.000 | nan | nan | ... | 85598.000 | 866.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 2684.105 | . 12 2020-06-27 | Iowa | IA | 3179849 | 28012.000 | 9841.000 | 131.000 | nan | 40.000 | 22.000 | ... | nan | 28012.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.000 | 9539.547 | . 13 2020-06-27 | Idaho | ID | 1826156 | 5148.000 | 1231.000 | nan | 309.000 | nan | nan | ... | nan | 4629.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 3469.696 | . 14 2020-06-27 | Illinois | IL | 12659682 | 142130.000 | 135056.000 | 1516.000 | nan | 400.000 | 225.000 | ... | nan | 141077.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.500 | 31649.205 | . 15 2020-06-27 | Indiana | IN | 6745354 | 44575.000 | 8234.000 | 595.000 | 6982.000 | 257.000 | 82.000 | ... | nan | 44575.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.700 | 18212.456 | . 16 2020-06-27 | Kansas | KS | 2910357 | 13538.000 | 12495.000 | nan | 1128.000 | nan | nan | ... | nan | 13538.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.300 | 9604.178 | . 17 2020-06-27 | Kentucky | KY | 4499692 | 14859.000 | 10576.000 | 387.000 | 2589.000 | 74.000 | nan | ... | nan | 14401.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.200 | 14399.014 | . 18 2020-06-27 | Louisiana | LA | 4645184 | 54769.000 | 11787.000 | 700.000 | nan | nan | 73.000 | ... | nan | 54769.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.300 | 15329.107 | . 19 2020-06-27 | Massachusetts | MA | 6976597 | 108443.000 | 100402.000 | 769.000 | 11310.000 | 143.000 | 90.000 | ... | nan | 103376.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.300 | 16046.173 | . 20 2020-06-27 | Maryland | MD | 6083116 | 66450.000 | 58358.000 | 478.000 | 10751.000 | 181.000 | nan | ... | nan | 66450.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 11557.920 | . 21 2020-06-27 | Maine | ME | 1345790 | 3154.000 | 484.000 | 24.000 | 345.000 | 7.000 | 5.000 | ... | 87604.000 | 2809.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.500 | 3364.475 | . 22 2020-06-27 | Michigan | MI | 10045029 | 69679.000 | 12427.000 | 557.000 | nan | 193.000 | 106.000 | ... | 931142.000 | 63009.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.500 | 25112.573 | . 23 2020-06-27 | Minnesota | MN | 5700671 | 35033.000 | 3180.000 | 300.000 | 3986.000 | 155.000 | nan | ... | nan | 35033.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.500 | 14251.678 | . 24 2020-06-27 | Missouri | MO | 6169270 | 20261.000 | 19265.000 | 680.000 | nan | nan | 66.000 | ... | 399926.000 | 20261.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.100 | 19124.737 | . 25 2020-06-27 | Mississippi | MS | 2989260 | 25531.000 | 7254.000 | 731.000 | 3078.000 | 169.000 | 90.000 | ... | nan | 25368.000 | 0 | 0 | 0 | 0 | 0 | nan | 4.000 | 11957.040 | . 26 2020-06-27 | Montana | MT | 1086759 | 852.000 | 226.000 | 9.000 | 95.000 | nan | nan | ... | nan | 852.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.300 | 3586.305 | . 27 2020-06-27 | North Carolina | NC | 10611862 | 60537.000 | 22304.000 | 888.000 | nan | nan | nan | ... | nan | 60537.000 | 0 | 0 | 0 | 0 | 0 | nan | 2.100 | 22284.910 | . 28 2020-06-27 | North Dakota | ND | 761723 | 3458.000 | 252.000 | 23.000 | 225.000 | nan | nan | ... | nan | 3458.000 | 0 | 0 | 0 | 0 | 0 | nan | 4.300 | 3275.409 | . 29 2020-06-27 | Nebraska | NE | 1952570 | 18524.000 | 5560.000 | 125.000 | 1312.000 | nan | nan | ... | nan | 18524.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.600 | 7029.252 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 5851 2020-02-20 | Washington | WA | 7797095 | 82.000 | 82.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5852 2020-02-19 | Washington | WA | 7797095 | 69.000 | 69.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5853 2020-02-18 | Washington | WA | 7797095 | 59.000 | 59.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5854 2020-02-17 | Washington | WA | 7797095 | 50.000 | 50.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5855 2020-02-16 | Washington | WA | 7797095 | 35.000 | 35.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5856 2020-02-15 | Washington | WA | 7797095 | 28.000 | 28.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5857 2020-02-14 | Washington | WA | 7797095 | 21.000 | 21.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5858 2020-02-13 | Washington | WA | 7797095 | 18.000 | 18.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5859 2020-02-12 | Washington | WA | 7797095 | 18.000 | 18.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5860 2020-02-11 | Washington | WA | 7797095 | 17.000 | 17.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5861 2020-02-10 | Washington | WA | 7797095 | 16.000 | 16.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5862 2020-02-09 | Washington | WA | 7797095 | 13.000 | 13.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5863 2020-02-08 | Washington | WA | 7797095 | 13.000 | 13.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5864 2020-02-07 | Washington | WA | 7797095 | 12.000 | 12.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5865 2020-02-06 | Washington | WA | 7797095 | 11.000 | 11.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5866 2020-02-05 | Washington | WA | 7797095 | 8.000 | 8.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5867 2020-02-04 | Washington | WA | 7797095 | 8.000 | 8.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5868 2020-02-03 | Washington | WA | 7797095 | 7.000 | 7.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5869 2020-02-02 | Washington | WA | 7797095 | 6.000 | 6.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5870 2020-02-01 | Washington | WA | 7797095 | 4.000 | 4.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5871 2020-01-31 | Washington | WA | 7797095 | 3.000 | 3.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5872 2020-01-30 | Washington | WA | 7797095 | 3.000 | 3.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5873 2020-01-29 | Washington | WA | 7797095 | 3.000 | 3.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5874 2020-01-28 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5875 2020-01-27 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5876 2020-01-26 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5877 2020-01-25 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5878 2020-01-24 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5879 2020-01-23 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5880 2020-01-22 | Washington | WA | 7797095 | 2.000 | 2.000 | nan | nan | nan | nan | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 1.700 | 13255.061 | . 5881 rows × 29 columns . ### Mark Bee (https://www.facebook.com/markbeenyc) - do you need a sippy cup lesson on this information? .",
            "url": "https://bielsnor.github.io/futureproof/futureproof-COVID19-usa-models/",
            "relUrl": "/futureproof-COVID19-usa-models/",
            "date": " • Jun 27, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Hospitalizations by State",
            "content": "# Imports import os import pandas as pd import csv import kaggle # other imports import numpy as np import matplotlib.pyplot as plt from sklearn.model_selection import train_test_split from sklearn.model_selection import GridSearchCV from sklearn.linear_model import ElasticNet from sklearn.linear_model import LinearRegression from sklearn.preprocessing import PolynomialFeatures from sklearn.metrics import mean_squared_error, mean_absolute_error, classification_report from sklearn.utils.testing import ignore_warnings from sklearn.exceptions import ConvergenceWarning from copy import copy import seaborn as sns from scipy.stats import norm import matplotlib.dates as mdates # import matplotlib.colors as mcolors # import random # import math # import time # from sklearn.linear_model import LinearRegression, BayesianRidge # from sklearn.model_selection import RandomizedSearchCV from sklearn.tree import DecisionTreeRegressor # from sklearn.svm import SVR from datetime import date, datetime from dateutil.parser import parse import us # import operator # plt.style.use(&#39;fivethirtyeight&#39;) import plotly.graph_objects as go from plotly.subplots import make_subplots %matplotlib inline . c: programdata anaconda3 lib site-packages sklearn utils deprecation.py:144: FutureWarning: The sklearn.utils.testing module is deprecated in version 0.22 and will be removed in version 0.24. The corresponding classes / functions should instead be imported from sklearn.utils. Anything that cannot be imported from sklearn.utils is now part of the private API. warnings.warn(message, FutureWarning) . Covid Tracking Dataset (w/ hospitalised data) . Source: https://covidtracking.com/ . Load and Clean the Data . all_cases = pd.read_csv(&#39;https://covidtracking.com/api/v1/states/daily.csv&#39;) # Delete unecessary rows for row in [&#39;negative&#39;, &#39;pending&#39;, &#39;hash&#39;, &#39;negativeIncrease&#39;, &#39;totalTestResults&#39;, &#39;totalTestResultsIncrease&#39;, &#39;dateChecked&#39;, &#39;fips&#39;, &#39;inIcuCumulative&#39;, &#39;onVentilatorCumulative&#39;, &#39;total&#39;, &#39;posNeg&#39;, &#39;deathIncrease&#39;, &#39;hospitalizedIncrease&#39;, &#39;positiveIncrease&#39;]: del all_cases[row] # TODO missing values # Do we get avg or missing values, or predict them? # See https://developerzen.com/data-mining-handling-missing-values-the-database-bd2241882e72 for i, row in all_cases.iterrows(): # Set Dates s = str(row[&#39;date&#39;]) all_cases.at[i, &#39;date&#39;] = date(year=int(s[0:4]), month=int(s[4:6]), day=int(s[6:8])) # Missing death figures means no death reports yet # These are set to 0 for i, row in all_cases.iterrows(): if np.isnan(row[&#39;death&#39;]): all_cases.at[i, &#39;death&#39;] = 0 . Missing values: Retrieving from other datasets or through merging columns (or both) . The following will be done: . Active Cases: Retrieved from JHU dataset and calculating $active = pos-dead-recovered$ | Beds per State: Retrieved from External Datasets | . # TODO Replace active cases with JHU and/or regression model (Selma) all_cases[&#39;active&#39;] = all_cases[&#39;positive&#39;] - all_cases[&#39;recovered&#39;] - all_cases[&#39;death&#39;] # change location of &#39;active&#39; column cols = list(all_cases) cols.insert(3, cols.pop(cols.index(&#39;active&#39;))) all_cases = all_cases.loc[:, cols] . # Load datasets for US population and Hospital beds per 1000 us_population = pd.read_csv(&#39;data/us_population.csv&#39;) hosp_beds = pd.read_csv(&#39;data/hospital_beds.csv&#39;) state_abbrev = pd.read_csv(&#39;data/us_state_names.csv&#39;) # add state abbreviations to us_population and hospital beds dataframe for state in state_abbrev[&#39;State&#39;].tolist(): # store state abbreviation in variable abbrev = state_abbrev.loc[state_abbrev[&#39;State&#39;] == state, &#39;Abbreviation&#39;].tolist()[0] # add abbrev to new column &#39;Abbreviation&#39; in us_population df us_population.loc[us_population[&#39;State&#39;] == state, &#39;Abbreviation&#39;] = abbrev # add abbrev to new column in hosp_beds df hosp_beds.loc[hosp_beds[&#39;Location&#39;] == state, &#39;Abbreviation&#39;] = abbrev # change order of columns of us_population cols = list(us_population) cols.insert(2, cols.pop(cols.index(&#39;Abbreviation&#39;))) us_population = us_population.loc[:, cols] # drop unnecessary columns of us_population us_population = us_population.drop(columns=[&#39;rank&#39;, &#39;Growth&#39;, &#39;Pop2018&#39;, &#39;Pop2010&#39;, &#39;growthSince2010&#39;, &#39;Percent&#39;, &#39;density&#39;]) # drop unnecessary columns of hosp_beds hosp_beds = hosp_beds.drop(columns=[&#39;Location&#39;, &#39;State/Local Government&#39;, &#39;Non-Profit&#39;, &#39;For-Profit&#39;]) # change order of columns of hosp_beds cols = list(hosp_beds) cols.insert(0, cols.pop(cols.index(&#39;Abbreviation&#39;))) hosp_beds = hosp_beds.loc[:, cols] . us_population.head() . State Abbreviation Pop . 0 Alabama | AL | 4908621 | . 1 Alaska | AK | 734002 | . 2 Arizona | AZ | 7378494 | . 3 Arkansas | AR | 3038999 | . 4 California | CA | 39937489 | . hosp_beds.head() . Abbreviation Total . 0 NaN | 2.4 | . 1 AL | 3.1 | . 2 AK | 2.2 | . 3 AZ | 1.9 | . 4 AR | 3.2 | . # filter out non-existing states like &#39;AS&#39; all_cases = all_cases[all_cases[&#39;state&#39;].isin(state_abbrev[&#39;Abbreviation&#39;].tolist())] . # see what filtered dataframe looks like all_cases.head() . date state positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently recovered dataQualityGrade ... totalTestsViral positiveTestsViral negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade . 0 2020-06-28 | AK | 883.0 | 348.0 | 12.0 | NaN | NaN | 1.0 | 521.0 | A | ... | 108300.0 | NaN | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | . 1 2020-06-28 | AL | 35441.0 | 15656.0 | 655.0 | 2703.0 | NaN | NaN | 18866.0 | B | ... | NaN | NaN | NaN | 34964.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 2 2020-06-28 | AR | 19310.0 | 5781.0 | 278.0 | 1373.0 | NaN | 63.0 | 13270.0 | A | ... | NaN | NaN | NaN | 19310.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 4 2020-06-28 | AZ | 73908.0 | 63394.0 | 2691.0 | 4617.0 | 666.0 | 475.0 | 8926.0 | A+ | ... | 509485.0 | NaN | NaN | 73497.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 5 2020-06-28 | CA | 211243.0 | NaN | 5956.0 | NaN | 1602.0 | NaN | NaN | B | ... | 3955952.0 | NaN | NaN | 211243.0 | 0 | 0 | 0 | 0 | 0 | NaN | . 5 rows × 25 columns . # Split dataframes by date df_split_by_date = dict(tuple(all_cases.groupby(&#39;date&#39;))) # Split dataframes by state df_split_by_state = dict(tuple(all_cases.groupby(&#39;state&#39;))) . # merge dataframes us_population and all_cases df_merge_uspop = all_cases.merge(us_population, how=&#39;left&#39;, left_on=&#39;state&#39;, right_on=&#39;Abbreviation&#39;) df_merge_uspop = df_merge_uspop.drop(columns=[&#39;Abbreviation&#39;]) df_merge_uspop = df_merge_uspop.rename(columns={&#39;Pop&#39;: &#39;population&#39;}) # change location of &#39;population&#39; column cols = list(df_merge_uspop) cols.insert(2, cols.pop(cols.index(&#39;population&#39;))) df_merge_uspop = df_merge_uspop.loc[:, cols] # merge dataframes hosp_beds and df_merge_uspop df_merge_hosp = df_merge_uspop.merge(hosp_beds, how=&#39;left&#39;, left_on=&#39;state&#39;, right_on=&#39;Abbreviation&#39;) df_merge_hosp = df_merge_hosp.drop(columns=[&#39;Abbreviation&#39;]) all_cases = df_merge_hosp.rename(columns={&#39;Total&#39;: &#39;bedsPerThousand&#39;}) . all_cases.head() . date state population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently recovered ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade State bedsPerThousand . 0 2020-06-28 | AK | 734002 | 883.0 | 348.0 | 12.0 | NaN | NaN | 1.0 | 521.0 | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | Alaska | 2.2 | . 1 2020-06-28 | AL | 4908621 | 35441.0 | 15656.0 | 655.0 | 2703.0 | NaN | NaN | 18866.0 | ... | NaN | 34964.0 | 0 | 0 | 0 | 0 | 0 | NaN | Alabama | 3.1 | . 2 2020-06-28 | AR | 3038999 | 19310.0 | 5781.0 | 278.0 | 1373.0 | NaN | 63.0 | 13270.0 | ... | NaN | 19310.0 | 0 | 0 | 0 | 0 | 0 | NaN | Arkansas | 3.2 | . 3 2020-06-28 | AZ | 7378494 | 73908.0 | 63394.0 | 2691.0 | 4617.0 | 666.0 | 475.0 | 8926.0 | ... | NaN | 73497.0 | 0 | 0 | 0 | 0 | 0 | NaN | Arizona | 1.9 | . 4 2020-06-28 | CA | 39937489 | 211243.0 | NaN | 5956.0 | NaN | 1602.0 | NaN | NaN | ... | NaN | 211243.0 | 0 | 0 | 0 | 0 | 0 | NaN | California | 1.8 | . 5 rows × 28 columns . # Calculate the total beds, and add the column all_cases[&#39;total_beds&#39;] = all_cases[&#39;population&#39;] / 1000 * all_cases[&#39;bedsPerThousand&#39;] . # change abbreviations to state names all_cases = all_cases.rename(columns={&#39;state&#39;: &#39;abbrev&#39;}) all_cases = all_cases.rename(columns={&#39;State&#39;: &#39;state&#39;}) . # change location of &#39;state&#39; column cols = list(all_cases) cols.insert(1, cols.pop(cols.index(&#39;state&#39;))) all_cases = all_cases.loc[:, cols] . all_cases.head() . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-28 | Alaska | AK | 734002 | 883.0 | 348.0 | 12.0 | NaN | NaN | 1.0 | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 2.2 | 1614.8044 | . 1 2020-06-28 | Alabama | AL | 4908621 | 35441.0 | 15656.0 | 655.0 | 2703.0 | NaN | NaN | ... | NaN | 34964.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.1 | 15216.7251 | . 2 2020-06-28 | Arkansas | AR | 3038999 | 19310.0 | 5781.0 | 278.0 | 1373.0 | NaN | 63.0 | ... | NaN | 19310.0 | 0 | 0 | 0 | 0 | 0 | NaN | 3.2 | 9724.7968 | . 3 2020-06-28 | Arizona | AZ | 7378494 | 73908.0 | 63394.0 | 2691.0 | 4617.0 | 666.0 | 475.0 | ... | NaN | 73497.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.9 | 14019.1386 | . 4 2020-06-28 | California | CA | 39937489 | 211243.0 | NaN | 5956.0 | NaN | 1602.0 | NaN | ... | NaN | 211243.0 | 0 | 0 | 0 | 0 | 0 | NaN | 1.8 | 71887.4802 | . 5 rows × 29 columns . Load and clean JHU data | Merge JHU dataset with main dataset | . # This cell takes some time, as it needs to connect to Kaggle Servers to retrieve data kaggle.api.authenticate() kaggle.api.dataset_download_files(&#39;benhamner/jhucovid19&#39;, path=&#39;./kaggle/input/jhucovid19/&#39;, unzip=True) . # Get Time-Series Data of cases as Pandas DataFrame dir_jhu = &#39;./kaggle/input/jhucovid19/csse_covid_19_data/csse_covid_19_daily_reports&#39; df_list = [] for dirname, _, files in os.walk(dir_jhu): for file in files: if &#39;gitignore&#39; not in file and &#39;README&#39; not in file: full_dir = os.path.join(dirname, file) df_list.append(pd.read_csv(full_dir)) jhu_df = pd.concat(df_list, axis=0, ignore_index=True, sort=True) # convert Last Update columns to datetime format jhu_df.loc[:, &#39;Last Update&#39;] = pd.to_datetime(jhu_df[&#39;Last Update&#39;]).apply(lambda x: x.date()) jhu_df.loc[:, &#39;Last_Update&#39;] = pd.to_datetime(jhu_df[&#39;Last_Update&#39;]).apply(lambda x: x.date()) # Combine Last Update with Last_Update jhu_df[&#39;LastUpdate&#39;] = jhu_df[&#39;Last_Update&#39;].combine_first(jhu_df[&#39;Last Update&#39;]) # Combine Country/Region with Country_Region jhu_df[&#39;CountryRegion&#39;] = jhu_df[&#39;Country/Region&#39;].combine_first(jhu_df[&#39;Country_Region&#39;]) # Retrieve only US data jhu_df = jhu_df[jhu_df[&#39;CountryRegion&#39;]==&#39;US&#39;] # Combine Province/State with Province_State jhu_df[&#39;ProvinceState&#39;] = jhu_df[&#39;Province/State&#39;].combine_first(jhu_df[&#39;Province_State&#39;]) # Drop unnecessary columns jhu_df = jhu_df.drop([&#39;Admin2&#39;, &#39;Lat&#39;, &#39;Latitude&#39;, &#39;Long_&#39;, &#39;Longitude&#39;, &#39;Combined_Key&#39;, &#39;Country/Region&#39;, &#39;Country_Region&#39;, &#39;Province/State&#39;, &#39;Province_State&#39;, &#39;Last Update&#39;, &#39;Last_Update&#39;, &#39;FIPS&#39;], axis=1) # Change column order cols = list(jhu_df) cols.insert(0, cols.pop(cols.index(&#39;CountryRegion&#39;))) cols.insert(1, cols.pop(cols.index(&#39;ProvinceState&#39;))) cols.insert(2, cols.pop(cols.index(&#39;LastUpdate&#39;))) jhu_df = jhu_df.loc[:, cols] # Change region to known US states state_abbrs_dict = {} for state in us.states.STATES: state_abbrs_dict[state.abbr] = state.name def toState(input_state, mapping): abbreviation = input_state.rstrip()[-2:] try: return_value = mapping[abbreviation] except KeyError: return_value = input_state return return_value jhu_df[&#39;ProvinceState&#39;] = jhu_df[&#39;ProvinceState&#39;].apply(lambda x: toState(x, state_abbrs_dict) if x != &#39;Washington, D.C.&#39; else &#39;District of Columbia&#39;) # Filter out unknown states jhu_df = jhu_df[jhu_df[&#39;ProvinceState&#39;].isin(all_cases.state.unique().tolist())] # Merge-sum rows with same date and State jhu_df = jhu_df.groupby([&#39;LastUpdate&#39;, &#39;ProvinceState&#39;]).agg( { &#39;Active&#39;: sum, &#39;Confirmed&#39;: sum, &#39;Deaths&#39;: sum, &#39;Recovered&#39;: sum } ).reset_index() jhu_df.tail() . LastUpdate ProvinceState Active Confirmed Deaths Recovered . 5190 2020-06-19 | Virginia | 54652.0 | 56238.0 | 1586.0 | 0.0 | . 5191 2020-06-19 | Washington | 25947.0 | 27192.0 | 1245.0 | 0.0 | . 5192 2020-06-19 | West Virginia | 2330.0 | 2418.0 | 88.0 | 0.0 | . 5193 2020-06-19 | Wisconsin | 23157.0 | 23876.0 | 719.0 | 0.0 | . 5194 2020-06-19 | Wyoming | 1126.0 | 1144.0 | 18.0 | 0.0 | . # Now that we have the JHU dataset relatively cleaned # we can go ahead and merge its data with our main dataset for i, row in all_cases.iterrows(): last_update = all_cases.at[i, &#39;date&#39;] state = all_cases.at[i, &#39;state&#39;] matching_row = jhu_df[jhu_df[&#39;ProvinceState&#39;] == state] matching_row = matching_row[matching_row[&#39;LastUpdate&#39;] == last_update].reset_index() if len(matching_row.values) &gt; 0: #all_cases.at[i, &#39;positive&#39;] = matching_row[&#39;Confirmed&#39;].values[0] all_cases.at[i, &#39;active&#39;] = matching_row[&#39;Active&#39;].values[0] #all_cases.at[i, &#39;recovered&#39;] = matching_row[&#39;Recovered&#39;].values[0] JHU was inconsistent, therefore removed #all_cases.at[i, &#39;death&#39;] = matching_row[&#39;Deaths&#39;].values[0] # Replace unknown recovery numbers with 0 if np.isnan(row[&#39;recovered&#39;]): all_cases.at[i, &#39;recovered&#39;] = 0 if all_cases.at[i, &#39;active&#39;] == 0 or np.isnan(row[&#39;active&#39;]): positive = all_cases.at[i, &#39;positive&#39;] recovered = all_cases.at[i, &#39;recovered&#39;] dead = all_cases.at[i, &#39;death&#39;] all_cases.at[i, &#39;active&#39;] = positive - recovered - dead all_cases.tail() . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 5927 2020-01-26 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5928 2020-01-25 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5929 2020-01-24 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5930 2020-01-23 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5931 2020-01-22 | Washington | WA | 7797095 | 2.0 | 2.0 | NaN | NaN | NaN | NaN | ... | NaN | NaN | 0 | 0 | 0 | 0 | 0 | NaN | 1.7 | 13255.0615 | . 5 rows × 29 columns . # Save formatted dataset offline in case of disaster dataset_file = &#39;results/all_cases.csv&#39; all_cases.to_csv(dataset_file) . # convert date to datetime format all_cases[&#39;date&#39;] = pd.to_datetime(all_cases[&#39;date&#39;]) . An Exploratory data analysis of the US dataset . Basic triad of the dataset: validating data types and data integrity of each row . dataset_file = &#39;results/all_cases.csv&#39; covid_df = pd.read_csv(dataset_file, index_col=0) # convert date to datetime format covid_df[&#39;date&#39;] = pd.to_datetime(covid_df[&#39;date&#39;]) covid_df.info() # set float format to 3 decimals pd.set_option(&#39;display.float_format&#39;, lambda x: &#39;%.3f&#39; % x) . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 5932 entries, 0 to 5931 Data columns (total 29 columns): date 5932 non-null datetime64[ns] state 5932 non-null object abbrev 5932 non-null object population 5932 non-null int64 positive 5932 non-null float64 active 5932 non-null float64 hospitalizedCurrently 3645 non-null float64 hospitalizedCumulative 3234 non-null float64 inIcuCurrently 1883 non-null float64 onVentilatorCurrently 1675 non-null float64 recovered 5932 non-null float64 dataQualityGrade 4998 non-null object lastUpdateEt 5577 non-null object dateModified 5577 non-null object checkTimeEt 5577 non-null object death 5932 non-null float64 hospitalized 3234 non-null float64 totalTestsViral 1592 non-null float64 positiveTestsViral 535 non-null float64 negativeTestsViral 535 non-null float64 positiveCasesViral 3108 non-null float64 commercialScore 5932 non-null int64 negativeRegularScore 5932 non-null int64 negativeScore 5932 non-null int64 positiveScore 5932 non-null int64 score 5932 non-null int64 grade 0 non-null float64 bedsPerThousand 5932 non-null float64 total_beds 5932 non-null float64 dtypes: datetime64[ns](1), float64(16), int64(6), object(6) memory usage: 1.4+ MB . covid_df.head() . date state abbrev population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . 0 2020-06-28 | Alaska | AK | 734002 | 883.000 | 348.000 | 12.000 | nan | nan | 1.000 | ... | nan | nan | 0 | 0 | 0 | 0 | 0 | nan | 2.200 | 1614.804 | . 1 2020-06-28 | Alabama | AL | 4908621 | 35441.000 | 15656.000 | 655.000 | 2703.000 | nan | nan | ... | nan | 34964.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.100 | 15216.725 | . 2 2020-06-28 | Arkansas | AR | 3038999 | 19310.000 | 5781.000 | 278.000 | 1373.000 | nan | 63.000 | ... | nan | 19310.000 | 0 | 0 | 0 | 0 | 0 | nan | 3.200 | 9724.797 | . 3 2020-06-28 | Arizona | AZ | 7378494 | 73908.000 | 63394.000 | 2691.000 | 4617.000 | 666.000 | 475.000 | ... | nan | 73497.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.900 | 14019.139 | . 4 2020-06-28 | California | CA | 39937489 | 211243.000 | 205338.000 | 5956.000 | nan | 1602.000 | nan | ... | nan | 211243.000 | 0 | 0 | 0 | 0 | 0 | nan | 1.800 | 71887.480 | . 5 rows × 29 columns . The NaN values may indicate that there were no to few Covid-19 patients at these date points. We further analyse the statistical values of the dataset columns to ensure data integrity and accuracy. . covid_df.describe() # TODO rounding up the numbers . population positive active hospitalizedCurrently hospitalizedCumulative inIcuCurrently onVentilatorCurrently recovered death hospitalized ... negativeTestsViral positiveCasesViral commercialScore negativeRegularScore negativeScore positiveScore score grade bedsPerThousand total_beds . count 5932.000 | 5932.000 | 5932.000 | 3645.000 | 3234.000 | 1883.000 | 1675.000 | 5932.000 | 5932.000 | 3234.000 | ... | 535.000 | 3108.000 | 5932.000 | 5932.000 | 5932.000 | 5932.000 | 5932.000 | 0.000 | 5932.000 | 5932.000 | . mean 6542964.221 | 21163.612 | 18746.569 | 1023.799 | 4369.803 | 441.040 | 224.801 | 4474.004 | 1101.755 | 4369.803 | ... | 293835.318 | 32231.612 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 2.626 | 15806.395 | . std 7387050.444 | 46807.027 | 42033.173 | 1927.101 | 12949.481 | 692.449 | 328.899 | 11042.022 | 2921.727 | 12949.481 | ... | 389283.058 | 56691.349 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 0.744 | 16159.661 | . min 567025.000 | 0.000 | 0.000 | 1.000 | 0.000 | 2.000 | 0.000 | 0.000 | 0.000 | 0.000 | ... | 17.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 1.600 | 1318.928 | . 25% 1778070.000 | 640.000 | 555.000 | 121.000 | 223.000 | 82.000 | 35.500 | 0.000 | 13.000 | 223.000 | ... | 50018.000 | 5033.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 2.100 | 3773.952 | . 50% 4499692.000 | 5122.000 | 4543.000 | 402.000 | 973.000 | 181.000 | 94.000 | 218.000 | 147.000 | 973.000 | ... | 140972.000 | 13770.500 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 2.500 | 11557.920 | . 75% 7797095.000 | 20840.750 | 17541.250 | 1032.000 | 3255.250 | 482.000 | 249.000 | 3140.500 | 782.250 | 3255.250 | ... | 360303.000 | 35463.250 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 3.100 | 19124.737 | . max 39937489.000 | 392539.000 | 356899.000 | 18825.000 | 89995.000 | 5225.000 | 2425.000 | 79974.000 | 24835.000 | 89995.000 | ... | 2070179.000 | 392539.000 | 0.000 | 0.000 | 0.000 | 0.000 | 0.000 | nan | 4.800 | 71887.480 | . 8 rows × 22 columns . # drop unnecessary columns covid_cleaned = covid_df.drop([&#39;hospitalized&#39;, &#39;bedsPerThousand&#39;], axis=1) covid_100k = covid_cleaned.copy() # list of columns to transform to per 100k columns_list = [&#39;positive&#39;, &#39;active&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;onVentilatorCurrently&#39;, &#39;total_beds&#39;] # add columns per 100k for column in columns_list: if column == &#39;total_beds&#39;: covid_100k[&#39;BedsPer100k&#39;.format(column)] = (covid_cleaned.loc[:, column] / covid_cleaned.loc[:, &#39;population&#39;]) * 100000 else: covid_100k[&#39;{}_100k&#39;.format(column)] = (covid_cleaned.loc[:, column] / covid_cleaned.loc[:, &#39;population&#39;]) * 100000 covid_100k = covid_100k.drop(columns_list, axis=1) . covid_100k[&#39;date&#39;] = pd.to_datetime(covid_100k[&#39;date&#39;]) start_date = &#39;2020-04-18&#39; end_date = &#39;2020-05-19&#39; mask = (covid_100k[&#39;date&#39;] &gt; start_date) &amp; (covid_100k[&#39;date&#39;] &lt;= end_date) covid_100k_last_month = covid_100k.loc[mask] . covid_100k_last_month_part1 = covid_100k_last_month.groupby(&#39;date&#39;).sum().loc[:, [&#39;positive_100k&#39;,&#39;active_100k&#39;,&#39;recovered_100k&#39;,&#39;death_100k&#39;,&#39;hospitalizedCumulative_100k&#39;]].diff(periods=1, axis=0) covid_100k_last_month_part2 = covid_100k_last_month.groupby(&#39;date&#39;).sum().loc[:, [&#39;inIcuCurrently_100k&#39;,&#39;onVentilatorCurrently_100k&#39;,&#39;BedsPer100k&#39;]] final_100k_last_month = covid_100k_last_month_part1.merge(covid_100k_last_month_part2, left_index=True, right_index=True) . final_100k_last_month.head() . positive_100k active_100k recovered_100k death_100k hospitalizedCumulative_100k inIcuCurrently_100k onVentilatorCurrently_100k BedsPer100k . date . 2020-04-19 nan | nan | nan | nan | nan | 153.528 | 80.717 | 13440.000 | . 2020-04-20 413.759 | 391.692 | 35.481 | 25.728 | 22.652 | 156.581 | 79.710 | 13440.000 | . 2020-04-21 387.394 | 360.446 | 65.218 | 30.520 | 31.446 | 166.081 | 78.603 | 13440.000 | . 2020-04-22 428.601 | 989.954 | 412.625 | 28.780 | 36.181 | 167.561 | 78.032 | 13440.000 | . 2020-04-23 452.031 | -2213.482 | 72.921 | 26.282 | 28.842 | 166.277 | 94.521 | 13440.000 | . final_100k_last_month.describe() . positive_100k active_100k recovered_100k death_100k hospitalizedCumulative_100k inIcuCurrently_100k onVentilatorCurrently_100k BedsPer100k . count 30.000 | 30.000 | 30.000 | 30.000 | 30.000 | 31.000 | 31.000 | 31.000 | . mean 399.188 | 364.943 | 147.172 | 23.271 | 39.160 | 134.117 | 73.503 | 13440.000 | . std 58.939 | 634.169 | 81.341 | 5.781 | 43.524 | 19.860 | 8.141 | 0.000 | . min 287.019 | -2213.482 | 35.481 | 13.315 | 9.507 | 109.602 | 61.622 | 13440.000 | . 25% 348.980 | 314.204 | 80.563 | 18.439 | 22.991 | 118.222 | 66.261 | 13440.000 | . 50% 405.026 | 366.234 | 127.774 | 24.119 | 28.295 | 127.613 | 74.706 | 13440.000 | . 75% 432.647 | 419.664 | 212.491 | 26.201 | 32.754 | 149.768 | 79.157 | 13440.000 | . max 544.349 | 2291.210 | 412.625 | 33.917 | 246.371 | 167.561 | 94.521 | 13440.000 | . # save description cleaned dataset to csv describe_file = &#39;results/final_100k_last_month.csv&#39; final_100k_last_month.describe().to_csv(describe_file) . Graphical Exploratory Analysis . Plotting histograms, scatterplots and boxplots to assess the distribution of the entire US dataset. . # Omitting the categorical (states/abbreviations) and time columns # There must be an easier way for you, but this was the easiest way I could think of covid_cleaned[&#39;date&#39;] = pd.to_datetime(covid_cleaned[&#39;date&#39;]) # mask data for last month start_date = &#39;2020-04-18&#39; end_date = &#39;2020-05-19&#39; mask = (covid_cleaned[&#39;date&#39;] &gt; start_date) &amp; (covid_cleaned[&#39;date&#39;] &lt;= end_date) covid_cleaned_last_month = covid_cleaned.loc[mask] plot_df = covid_cleaned_last_month[[&#39;population&#39;, &#39;active&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;onVentilatorCurrently&#39;, &#39;total_beds&#39;]] plot_df_last_month = covid_100k_last_month[[&#39;population&#39;, &#39;active_100k&#39;, &#39;recovered_100k&#39;, &#39;death_100k&#39;, &#39;hospitalizedCurrently_100k&#39;, &#39;inIcuCurrently_100k&#39;, &#39;onVentilatorCurrently_100k&#39;, &#39;BedsPer100k&#39;]] . timeseries_usa_df = covid_100k.loc[:, [&#39;date&#39;, &#39;positive_100k&#39;, &#39;active_100k&#39;, &#39;recovered_100k&#39;, &#39;death_100k&#39;, &#39;hospitalizedCurrently_100k&#39;, &#39;inIcuCurrently_100k&#39;, &#39;onVentilatorCurrently_100k&#39;, &#39;BedsPer100k&#39;]].groupby(&#39;date&#39;).sum().reset_index() # timeseries_usa_df[&#39;log_positive&#39;] = np.log(timeseries_usa_df[&#39;positive_100k&#39;]) # timeseries_usa_df[&#39;log_active&#39;] = np.log(timeseries_usa_df[&#39;active_100k&#39;]) # timeseries_usa_df[&#39;log_recovered&#39;] = np.log(timeseries_usa_df[&#39;recovered_100k&#39;]) # timeseries_usa_df[&#39;log_death&#39;] = np.log(timeseries_usa_df[&#39;death_100k&#39;]) . timeseries_usa_df.tail() . date positive_100k active_100k recovered_100k death_100k hospitalizedCurrently_100k inIcuCurrently_100k onVentilatorCurrently_100k BedsPer100k . 154 2020-06-24 | 33315.285 | 19401.954 | 12359.391 | 1553.940 | 408.570 | 68.612 | 36.820 | 13440.000 | . 155 2020-06-25 | 33812.912 | 19730.969 | 12498.864 | 1583.079 | 414.087 | 67.864 | 36.962 | 13440.000 | . 156 2020-06-26 | 34335.924 | 20098.997 | 12643.998 | 1592.929 | 404.115 | 67.051 | 34.318 | 13440.000 | . 157 2020-06-27 | 34829.638 | 20417.559 | 12812.241 | 1599.839 | 407.257 | 68.533 | 35.118 | 13440.000 | . 158 2020-06-28 | 35334.565 | 20809.528 | 12921.408 | 1603.630 | 402.011 | 65.968 | 33.930 | 13440.000 | . # get data from last day # plot_df_last_date = plot_df.loc[covid_df[&#39;date&#39;] == &#39;2020-05-18&#39;] # Plotting histograms to gain insight of the distribution shape, skewness and scale fig, axs = plt.subplots(4,2,figsize = (16, 16)) sns.set() for i, column in enumerate(plot_df_last_month.columns): if (i + 1) % 2 == 0: ax = axs[(i//2), 1] else: ax = axs[(i//2), 0] sns.distplot(plot_df_last_month[column], fit=norm, fit_kws=dict(label=&#39;normality&#39;), hist_kws=dict(color=&#39;plum&#39;, edgecolor=&#39;k&#39;, linewidth=1, label=&#39;frequency&#39;), ax=ax, color=&#39;#9d53ad&#39;) ax.legend(loc=&#39;upper right&#39;) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Looking at linearity and variance with scatterplots # Removing the target variable and saving it in another df target = plot_df.hospitalizedCurrently indep_var = plot_df.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var.columns): ax=fig.add_subplot(4, 3, i+1) sns.regplot(x=indep_var[col], y=target, data=indep_var, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;, &#39;label&#39;: &#39;hospitCurr&#39;}) plt.suptitle(&#39;Scatterplots with Target Hospitalized Patients Showing Growth Trajectories&#39;, fontsize=23) plt.legend() plt.tight_layout() fig.subplots_adjust(top=0.95) . # Assessing the normality of the distribution with a boxplot # Boxplot with removed outliers fig, ax = plt.subplots(figsize = (16, 12)) for i, col in enumerate(plot_df.columns): ax=fig.add_subplot(4, 3, i+1) sns.boxplot(x=plot_df[col], data=plot_df, color=&#39;lightblue&#39;, showfliers=False) plt.suptitle(&#39;Boxplots of Independent Variables&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # get data from last day plot_df_last_date = plot_df.loc[covid_df[&#39;date&#39;] == &#39;2020-05-18&#39;] fig, ax = plt.subplots(figsize = (16, 12)) for i, col in enumerate(plot_df_last_date.columns): ax=fig.add_subplot(4, 3, i+1) sns.boxplot(x=plot_df_last_date[col], data=plot_df, color=&#39;lightblue&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . Analysis of Hospitalizations by State . Since the normality of the independent variables is highly variable do to temporal and precision differences from each state, we further assess each state&#39;s data by viewing trends on the independent variables in both scatter and box-and-whisker plots. . New York: . # Split covid_df into subset with only NY values new_york = covid_df.loc[covid_df[&#39;abbrev&#39;] == &#39;NY&#39;] fig, ax = plt.subplots(figsize = (16, 12)) # Timeseries plt plt.plot(new_york.date, new_york.hospitalizedCurrently, linewidth=3.3) plt.title(&#39;Number of Patients in NY Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . C: Users Doctor Gomez AppData Roaming Python Python37 site-packages pandas plotting _converter.py:129: FutureWarning: Using an implicitly registered datetime converter for a matplotlib plotting method. The converter was registered by pandas on import. Future versions of pandas will require you to explicitly register matplotlib converters. To register the converters: &gt;&gt;&gt; from pandas.plotting import register_matplotlib_converters &gt;&gt;&gt; register_matplotlib_converters() . Text(0, 0.5, &#39;No. Patients&#39;) . # Omit the categorical and date cols new_york = new_york[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;hospitalizedCumulative&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] . # Scatter plots NY # Split dependent var from independent variables target_ny = new_york.hospitalizedCurrently indep_var_ny = new_york.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ny.columns): ax=fig.add_subplot(3, 3, i+1) sns.regplot(x=indep_var_ny[col], y=target_ny, data=indep_var_ny, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NY fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(new_york.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=new_york[col], data=new_york, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables NY&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . California: . cali = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;CA&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;California&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(cali.date, cali.hospitalizedCurrently, linewidth=4.7) plt.title(&#39;Number of Patients in CA Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values cali[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] cali.head() # Omit the NaN cols cali = cali[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots CA # Split dependent var from independent variables target_ca = cali.hospitalizedCurrently indep_var_ca = cali.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ca.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_ca[col], y=target_ca, data=indep_var_ca, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables CA&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of CA fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(cali.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=cali[col], data=cali, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables CA&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endcali . Texas: . texas = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;TX&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Texas&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(texas.date, texas.hospitalizedCurrently, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Patients in TX Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(texas.date, texas.death, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Cummulative Deaths in Texas&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(texas.date, texas.totalTestsViral, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Cummulative Viral Tests in Texas&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values texas[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] texas.head() # Omit the NaN cols texas = texas[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots TX # Split dependent var from independent variables target_tx = texas.hospitalizedCurrently indep_var_tx = texas.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_tx.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_tx[col], y=target_tx, data=indep_var_tx, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables TX&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of TX fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(texas.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=texas[col], data=texas, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables TX&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endtx . South Carolina: . sc = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;SC&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;South Carolina&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(sc.date, sc.hospitalizedCurrently, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Patients in South Carolina Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(sc.date, sc.death, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Cummulative Deaths in South Carolina&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(sc.date, sc.totalTestsViral, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Cummulative Viral Tests in South Carolina&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(sc.date, sc.positiveTestsViral, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Cummulative Positive Viral Tests in South Carolina&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(sc.date, sc.positiveTestsViral/sc.totalTestsViral*100, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Viral Infection Rate in South Carolina&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;% Infection Rate&#39;) . Text(0, 0.5, &#39;% Infection Rate&#39;) . # Checking which cols have NaN values sc[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] sc.head() # Omit the NaN cols sc = sc[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots SC # Split dependent var from independent variables target_sc = sc.hospitalizedCurrently indep_var_sc = sc.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_sc.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_sc[col], y=target_sc, data=indep_var_sc, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables South Carolina&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of SC fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(sc.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=sc[col], data=sc, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables South Carolina&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endsouthcarolina . Nevada: . nevada = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;NV&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Nevada&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(nevada.date, nevada.hospitalizedCurrently, linewidth=4.7) plt.title(&#39;Number of Patients in Nevada Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(nevada.date, nevada.inIcuCurrently, linewidth=4.7) plt.title(&#39;Number of Patients in Nevada Currently Hospitalized in ICU&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(nevada.date, nevada.onVentilatorCurrently, linewidth=4.7) plt.title(&#39;Number of Patients in Nevada Currently on a Ventilator&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values nevada[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] nevada.head() # Omit the NaN cols nevada = nevada[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots NV # Split dependent var from independent variables target_nv = nevada.hospitalizedCurrently indep_var_nv = nevada.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_nv.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_nv[col], y=target_nv, data=indep_var_nv, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables Nevada&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of NV fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(nevada.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=nevada[col], data=nevada, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables Nevada&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endnevada . Arizona: . arizona = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;AZ&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Arizona&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(arizona.date, arizona.hospitalizedCurrently, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Patients in Arizona Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(arizona.date, arizona.inIcuCurrently, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Patients in Arizona Currently Hospitalized in ICU&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(arizona.date, arizona.onVentilatorCurrently, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Patients in Arizona Currently on Ventilator&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values arizona[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] arizona.head() # Omit the NaN cols arizona = arizona[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots AZ # Split dependent var from independent variables target_az = arizona.hospitalizedCurrently indep_var_az = arizona.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_az.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_az[col], y=target_az, data=indep_var_az, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables Arizona&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of AZ fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(arizona.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=arizona[col], data=arizona, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables Arizona&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endarizona . Mississippi: . mississippi = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;MS&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Mississippi&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(mississippi.date, mississippi.hospitalizedCurrently, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Patients in Mississippi Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(mississippi.date, mississippi.inIcuCurrently, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Patients in Mississippi Currently in ICU&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(mississippi.date, mississippi.onVentilatorCurrently, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Patients in Mississippi Currently on a Ventilator&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(mississippi.date, mississippi.death, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Patients in Mississippi Killed&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values mississippi[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] mississippi.head() # Omit the NaN cols mississippi = mississippi[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots MS # Split dependent var from independent variables target_ms = texas.hospitalizedCurrently indep_var_ms = texas.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ms.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_ms[col], y=target_ms, data=indep_var_ms, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables Mississippi&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of MS fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(texas.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=mississippi[col], data=mississippi, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables Mississippi&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endmississippi . Utah: . utah = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;UT&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Utah&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(utah.date, utah.hospitalizedCurrently, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Patients in UT Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(utah.date, utah.inIcuCurrently, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Patients in UT Currently in ICU&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(utah.date, utah.death, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Cummulative Deaths in Utah&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values utah[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] utah.head() # Omit the NaN cols utah = utah[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots UT # Split dependent var from independent variables target_ut = utah.hospitalizedCurrently indep_var_ut = utah.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_tx.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_ut[col], y=target_ut, data=indep_var_ut, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables Utah&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endutah . Georgia: . georgia = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;GA&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Georgia&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(georgia.date, georgia.hospitalizedCurrently, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Patients in Georgia Currently Hospitalized&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(georgia.date, georgia.totalTestsViral, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Cummulative Viral Tests in Georgia&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(georgia.date, georgia.positiveTestsViral, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Number of Cummulative Positive Viral Tests in Georgia&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(georgia.date, georgia.positiveTestsViral/georgia.totalTestsViral*100, linewidth=4.7, color=&#39;r&#39;) plt.title(&#39;Infection Rate in Georgia&#39;, fontsize=23) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;% Infection Rate&#39;) . Text(0, 0.5, &#39;% Infection Rate&#39;) . # Checking which cols have NaN values georgia[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] georgia.head() # Omit the NaN cols georgia = georgia[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots GA # Split dependent var from independent variables target_ga = georgia.hospitalizedCurrently indep_var_ga = georgia.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ga.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_ga[col], y=target_ga, data=indep_var_ga, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables Georgia&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of GA fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(georgia.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=georgia[col], data=georgia, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables Georgia&#39;, fontsize=23) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endgeorgia . Alabama: . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values bama[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] bama.head() # Omit the NaN cols bama = bama[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots AL # Split dependent var from independent variables target_al = bama.hospitalizedCurrently indep_var_al = bama.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_al.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_al[col], y=target_al, data=indep_var_al, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables Alabama&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of AL fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(bama.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=bama[col], data=bama, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables Alabama&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endalabama . Oklahoma: . oklahoma = covid_df.loc[(covid_df[&#39;abbrev&#39;] == &#39;OK&#39;) &amp; (covid_df[&#39;state&#39;]== &#39;Oklahoma&#39;)] . # TODO fix legend/axis/plot alltogether # Timeseries plt fig, ax = plt.subplots(figsize = (16, 12)) plt.plot(oklahoma.date, oklahoma.hospitalizedCurrently) plt.title(&#39;Number of Patients in OK Currently Hospitalized&#39;) plt.xlabel(&#39;Date&#39;) plt.ylabel(&#39;No. Patients&#39;) . Text(0, 0.5, &#39;No. Patients&#39;) . # Checking which cols have NaN values oklahoma[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;, &#39;hospitalized&#39;]] oklahoma.head() # Omit the NaN cols oklahoma = oklahoma[[&#39;positive&#39;, &#39;active&#39;, &#39;hospitalizedCurrently&#39;, &#39;inIcuCurrently&#39;, &#39;recovered&#39;, &#39;death&#39;]] . # Scatter plots OK # Split dependent var from independent variables target_ok = oklahoma.hospitalizedCurrently indep_var_ok = oklahoma.drop(columns=[&#39;hospitalizedCurrently&#39;]) fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(indep_var_ok.columns): ax=fig.add_subplot(2, 3, i+1) sns.regplot(x=indep_var_ok[col], y=target_ok, data=indep_var_ok, label=col, scatter_kws={&#39;s&#39;:10}, line_kws={&quot;color&quot;: &quot;plum&quot;}) plt.suptitle(&#39;Distributions of Independent Variables OK&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . # Boxplot of OK fig, ax = plt.subplots(figsize = (16, 16)) for i, col in enumerate(oklahoma.columns): ax=fig.add_subplot(3, 3, i+1) sns.boxplot(x=oklahoma[col], data=oklahoma, color=&#39;lightpink&#39;, showfliers=True) plt.suptitle(&#39;Boxplots of Independent Variables OK&#39;, fontsize=18) plt.tight_layout() fig.subplots_adjust(top=0.95) . ###endoklahoma . Assessing Correlation of Independent Variables . # TODO add some explanation / look more into collinear variables . # Heatmap of correlations # Save correlations to variable corr = covid_cleaned.corr(method=&#39;pearson&#39;) # We can create a mask to not show duplicate values mask = np.triu(np.ones_like(corr, dtype=np.bool)) # Set up the matplotlib figure fig, ax = plt.subplots(figsize=(16,16)) # Generate heatmap sns.heatmap(corr, annot=True, mask=mask, cmap=&#39;GnBu&#39;, center=0, square=True, linewidths=.5, cbar_kws={&quot;shrink&quot;: .5}) . Build model for dependent Variable . To be used to predict current hospitalizations | Having more complete variables for in ICU currently and on Ventilator Currently will allow us to predict these numbers as well. | . # We compare three models: # - Polynomial Regression # - Linear Regression # - ElasticNet # Copy DFs to not mess up original one # We will use model_df for our regression model model_df = all_cases.copy() # Delete redundant rows for row in [&#39;abbrev&#39;, &#39;bedsPerThousand&#39;, &#39;hospitalized&#39;, &#39;state&#39;, &#39;hospitalizedCumulative&#39;, &#39;dataQualityGrade&#39;, &#39;lastUpdateEt&#39;]: del model_df[row] # Drop NaN values for hospitalizedCurrently model_df = model_df.dropna(subset=[&#39;hospitalizedCurrently&#39;]) # Drop Values with abnormal active-hospitalised ratios (outside Conf. Interval) model_df[&#39;ratio_hospital&#39;] = model_df[&#39;hospitalizedCurrently&#39;] / model_df[&#39;active&#39;] model_df = model_df[~(model_df[&#39;ratio_hospital&#39;] &gt;= model_df.ratio_hospital.quantile(0.99))] #model_df = model_df[~(model_df[&#39;ratio_hospital&#39;] &lt;= model_df[&#39;ratio_hospital&#39;].median())] del model_df[&#39;ratio_hospital&#39;] # Get peek of model to use model_df.describe() . ### Mark Bee (https://www.facebook.com/markbeenyc) - do you need a sippy cup lesson on this information? .",
            "url": "https://bielsnor.github.io/futureproof/futureproof-COVID19-us-hosp/",
            "relUrl": "/futureproof-COVID19-us-hosp/",
            "date": " • Jun 26, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "COVID-19-Growth By State (US)",
            "content": ". Warning: The number of cases data can be heavily biased depending on a state&#8217;s testing procedures and how widely the population is tested. Read with caution. . #Click on each state to see data . ###data sourced from JHU, WHO, Varaious US Federal Agencies .",
            "url": "https://bielsnor.github.io/futureproof/futureproof-6COVID19-USA/",
            "relUrl": "/futureproof-6COVID19-USA/",
            "date": " • Jun 4, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Title",
            "content": "# Compare Death Rate Trajectories &gt; Comparing different countries&#39; death rate trajectories with those of Italy, South Korea, Japan and Lombardy, as well as US states. - comments: false - toc: true - categories: [growth, compare, death, interactive] - image: images/covid-compare-country-death-trajectories.png - permalink: /futureproof-COVID19-girls-v-trump/ How do female led countries compare to the United States with regard to COVID19 death rate trajectory? . Click (Shift+ for multiple) on Countries legend to filter the visualization. . Last Updated on April, 22 2020",
            "url": "https://bielsnor.github.io/futureproof/2020/04/17/death-traj_females_v_trump.html",
            "relUrl": "/2020/04/17/death-traj_females_v_trump.html",
            "date": " • Apr 17, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "COVID-19-Growth By State (US)",
            "content": ". Tip: Click (Shift+ for multiple) on states in the legend to filter the visualizations below. Click outside the legend to highlight all states. . Total Cases . . Warning: The number of cases per capita can be heavily biased depending on a state&#8217;s testing procedures and how widely the population is tested. Read with caution. . Total Deaths . ###Click on each state to see data .",
            "url": "https://bielsnor.github.io/futureproof/futureproof-COVID19-USA/",
            "relUrl": "/futureproof-COVID19-USA/",
            "date": " • Apr 17, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "How many cases of COVID-19 does each U.S. state really have?",
            "content": ". Note: This dashboard contains the results of a predictive model. The author has tried to make it as accurate as possible. But the COVID-19 situation is changing quickly, and these models inevitably include some level of speculation. . COVID-19 Case Estimates, by State . Definition Of Fields: . Reported Cases: The number of cases reported by each state, which is a function of how many tests are positive. | Est Cases: The predicted number of cases, accounting for the fact that not everyone is tested. | Est Range: The 95% confidence interval of the predicted number of cases. | Ratio: Estimated Cases divided by Reported Cases. | Tests per Million: The number of tests administered per one million people. The less tests administered per capita, the larger the difference between reported and estimated number of cases, generally. | Cases per Million: The number of reported cases per on million people. | Positive Test Rate: The reported percentage of positive tests. | . Appendix: Model Diagnostics . Derived relationship between Test Capacity and Case Under-reporting . Plotted is the estimated relationship between test capacity (in terms of people per test -- larger = less testing) and the likelihood a COVID-19 case is reported (lower = more under-reporting of cases). . The lines represent the posterior samples from our MCMC run (note the x-axis is plotted on a log scale). The rug plot shows the current test capacity for each state (black &#39;|&#39;) and the capacity one week ago (cyan &#39;+&#39;). For comparison, South Korea&#39;s testing capacity is currently at the very left of the graph (200 people per test). . About this Analysis . This analysis was done by Joseph Richards. . This project1 uses the testing rates per state from https://covidtracking.com/, which reports case counts and mortality by state. This is used to estimate the number of unreported (untested) COVID-19 cases in each U.S. state. . The analysis makes a few assumptions: . The probability that a case is reported by a state is a function of the number of tests run per person in that state. Hence the degree of under-reported cases is a function of tests run per capita. | The underlying mortality rate is the same across every state. | Patients take time to succumb to COVID-19, so the mortality counts today reflect the case counts 7 days ago. E.g., mortality rate = (cumulative deaths today) / (cumulative cases 7 days ago). | The model attempts to find the most likely relationship between state-wise test volume (per capita) and under-reporting, such that the true underlying mortality rates between the individual states are as similar as possible. The model simultaneously finds the most likely posterior distribution of mortality rates, the most likely true case count per state, and the test volume vs. case underreporting relationship. . . Full details about the model are available at: https://github.com/jwrichar/COVID19-mortality&#8617; . |",
            "url": "https://bielsnor.github.io/futureproof/covid-19-us-case-estimation/",
            "relUrl": "/covid-19-us-case-estimation/",
            "date": " • Mar 31, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Estimating The Infected Population From Deaths",
            "content": ". Note: This dashboard contains the results of a predictive model. The author has tried to make it as accurate as possible. But the COVID-19 situation is changing quickly, and these models inevitably include some level of speculation. . Estimated Infected Population By Country . with respect to days since outbreak . Tip: Click (Shift+ for multiple) on countries in the legend to filter the visualization. . FileNotFoundError Traceback (most recent call last) C: ProgramData Anaconda3 lib site-packages selenium webdriver common service.py in start(self) 75 stderr=self.log_file, &gt; 76 stdin=PIPE) 77 except TypeError: C: ProgramData Anaconda3 lib subprocess.py in __init__(self, args, bufsize, executable, stdin, stdout, stderr, preexec_fn, close_fds, shell, cwd, env, universal_newlines, startupinfo, creationflags, restore_signals, start_new_session, pass_fds, encoding, errors, text) 799 errread, errwrite, --&gt; 800 restore_signals, start_new_session) 801 except: C: ProgramData Anaconda3 lib subprocess.py in _execute_child(self, args, executable, preexec_fn, close_fds, pass_fds, cwd, env, startupinfo, creationflags, shell, p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite, unused_restore_signals, unused_start_new_session) 1206 os.fspath(cwd) if cwd is not None else None, -&gt; 1207 startupinfo) 1208 finally: FileNotFoundError: [WinError 2] The system cannot find the file specified During handling of the above exception, another exception occurred: WebDriverException Traceback (most recent call last) &lt;ipython-input-4-13d297b27ddd&gt; in &lt;module&gt; 2 # Plot estimated absolute number of infected 3 plot1 = plot(data_countries_pc, &#34;line&#34;, True) -&gt; 4 plot1.save(&#34;../images/covid-estimate-infections.png&#34;) 5 plot1 C: ProgramData Anaconda3 lib site-packages altair vegalite v4 api.py in save(self, fp, format, override_data_transformer, scale_factor, vegalite_version, vega_version, vegaembed_version, **kwargs) 445 if override_data_transformer: 446 with data_transformers.disable_max_rows(): --&gt; 447 result = save(**kwds) 448 else: 449 result = save(**kwds) C: ProgramData Anaconda3 lib site-packages altair utils save.py in save(chart, fp, vega_version, vegaembed_version, format, mode, vegalite_version, embed_options, json_kwds, webdriver, scale_factor, **kwargs) 100 vegaembed_version=vegaembed_version, 101 webdriver=webdriver, --&gt; 102 scale_factor=scale_factor, **kwargs) 103 if format == &#39;png&#39;: 104 write_file_or_filename(fp, mimebundle[&#39;image/png&#39;], mode=&#39;wb&#39;) C: ProgramData Anaconda3 lib site-packages altair utils mimebundle.py in spec_to_mimebundle(spec, format, mode, vega_version, vegaembed_version, vegalite_version, **kwargs) 54 vega_version=vega_version, 55 vegaembed_version=vegaembed_version, &gt; 56 vegalite_version=vegalite_version, **kwargs) 57 if format == &#39;png&#39;: 58 render = base64.b64decode(render.split(&#39;,&#39;, 1)[1].encode()) C: ProgramData Anaconda3 lib site-packages altair utils headless.py in compile_spec(spec, format, mode, vega_version, vegaembed_version, vegalite_version, scale_factor, driver_timeout, webdriver) 155 webdriver_options.add_argument(&#39;--no-sandbox&#39;) 156 --&gt; 157 driver = webdriver_class(options=webdriver_options) 158 159 try: C: ProgramData Anaconda3 lib site-packages selenium webdriver chrome webdriver.py in __init__(self, executable_path, port, options, service_args, desired_capabilities, service_log_path, chrome_options, keep_alive) 71 service_args=service_args, 72 log_path=service_log_path) &gt; 73 self.service.start() 74 75 try: C: ProgramData Anaconda3 lib site-packages selenium webdriver common service.py in start(self) 81 raise WebDriverException( 82 &#34;&#39;%s&#39; executable needs to be in PATH. %s&#34; % ( &gt; 83 os.path.basename(self.path), self.start_error_message) 84 ) 85 elif err.errno == errno.EACCES: WebDriverException: Message: &#39;chromedriver&#39; executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home . Latest Country Estimates . Infected vs. number of confirmed cases . Allows you to compare how countries have been tracking the true number of infected people. The smaller deviation from the dashed line (45 degree line) the better job at tracking the true number of infected people. . . Tip: Click (Shift+ for multiple) on countries in the legend to filter the visualization. . Latest Observed vs. Estimate of Infected Cases . Methodology . We argue that the number of infected in the past can be inferred using today&#39;s number of deaths and average fatality rate from confirmed cases in the following way: . $$I_{t-j} = frac{D_t}{{CFR}_t}$$ . where $I_t$ = number of infected, $D_t$ = number of deaths, and ${CFR}_t $ = case fatality rate = $ frac{D}{C}$. The $j$ depends on the average number of days that covid patients die after having the first symptoms. . Assumption 1: The case fatality rate is a good proxy for the fatality rate of the infected population . Then, in order to estimate the current number of infected $I_t$ we need to estimate its growth rate from $t-j$ to $t$. . $$I_t = (1+ hat{g})^j I_{t-j}$$ . Assumption 2: The growth rate of infected $ hat{g}$ is an unbiased estimate of $g$ . . For now we estimate $g$ using the average growth rate since having the first infected person. . Assumption 3: It takes on average 8 days to die after having the first symptoms. . This analysis was conducted by Joao B. Duarte. Relevant sources are listed below: . 2019 Novel Coronavirus COVID-19 (2019-nCoV) Data Repository by Johns Hopkins CSSE GitHub repository. . | Feenstra, Robert C., Robert Inklaar and Marcel P. Timmer (2015), &quot;The Next Generation of the Penn World Table&quot; American Economic Review, 105(10), 3150-3182 . |",
            "url": "https://bielsnor.github.io/futureproof/covid-infected/",
            "relUrl": "/covid-infected/",
            "date": " • Mar 30, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "COVID-19 Growth Rate Prediction",
            "content": ". Note: This dashboard contains the results of a predictive model. The model is assuming an exponential growth rate in the initial stages of the COVID19 pandemic. Data is changing hourly therefore the accuracy of the model is variable. This is for informational purposes only. . Predicted Cases By Country . Select a country from the drop down list below to toggle the visualization. . Growth Rate Predictions . Text(0.5, 0.98, &#39;Posterior of daily growth&#39;) . Model Diagnostics - Trace Plots . The following trace plots help to assess the convergence of the MCMC sampler. You can safely ignore this if not familiar with MCMC. . Analysis Overview . The model that we are building assumes exponential growth. This is only applicable to the initial stages of a pandemic outbreak once growth slows the accuracy of the model will deteriorate to statistical insignificance. However, in the early stages of an outbreak it can provide an accurate scale and trajectory.1 . We assume a negative binomial likelihood as we are dealing with count data. A Poisson could also be used but the negative binomial allows us to also model the variance separately to give more flexibility. . The model is also hierarchical, pooling information from individual countries. . . This notebook gets up-to-date data from the &quot;2019 Novel Coronavirus COVID-19 (2019-nCoV) Data Repository by Johns Hopkins CSSE&quot; GitHub repository. This code is provided under the BSD-3 License.&#8617; . |",
            "url": "https://bielsnor.github.io/futureproof/growth-bayes/",
            "relUrl": "/growth-bayes/",
            "date": " • Mar 30, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "COVID-19 Deaths Per Capita",
            "content": "Deaths Per Million Of Inhabitants . Since reaching at least 1 death per million . Tip: Click (Shift+ for multiple) on countries in the legend to filter the visualization. . Last Available Total Deaths By Country: . Appendix . . Warning: The following chart, &quot;Cases Per Million of Habitants&quot; is biased depending on how widely a country administers tests. Please read with caution. . Cases Per Million of Habitants . Last Available Cases Per Million By Country: . Data Source: &quot;2019 Novel Coronavirus COVID-19 (2019-nCoV) Data Repository by Johns Hopkins CSSE&quot; GitHub repository. . Research: Feenstra, Robert C., Robert Inklaar and Marcel P. Timmer (2015), &quot;The Next Generation of the Penn World Table&quot; American Economic Review, 105(10), 3150-3182 .",
            "url": "https://bielsnor.github.io/futureproof/futureproof-COVID19-covid-compare-permillion/",
            "relUrl": "/futureproof-COVID19-covid-compare-permillion/",
            "date": " • Mar 28, 2020"
        }
        
    
  
    
        ,"post12": {
            "title": "Compare Death Rate Trajectories",
            "content": "Comparing Death Trajectory by Country . Where does your country stand today compared to Lombardy? . Click (Shift+ for multiple) on Countries legend to filter the visualization. . Last Updated on April, 15 2020 Select a country from the drop down list below to toggle the visualization. . A Lesson from Lombardy We Must Head . Lombardy, a small region of Italy with a population of only 10 million people has experienced an extremely high death rate. This shows that the virus has a high mortality rate even on a small demographic scale, likely due to overwhelmed healthcare services. . Where does your country stand in comparison to Lombardy? . Click (Shift+ for multiple) on Countries legend to filter the visualization. .",
            "url": "https://bielsnor.github.io/futureproof/futureproof-COVID19-compare-country-death-trajectories/",
            "relUrl": "/futureproof-COVID19-compare-country-death-trajectories/",
            "date": " • Mar 27, 2020"
        }
        
    
  
    
        ,"post13": {
            "title": "COVID-19-Growth By State (US)",
            "content": ". Tip: Click (Shift+ for multiple) on states in the legend to filter the visualizations below. Click outside the legend to highlight all states. . Total Cases . . Warning: The number of cases per capita can be heavily biased depending on a state&#8217;s testing procedures and how widely the population is tested. Read with caution. . Total Deaths . ###Click on each state to see data .",
            "url": "https://bielsnor.github.io/futureproof/futureproof-COVID19-USA/",
            "relUrl": "/futureproof-COVID19-USA/",
            "date": " • Mar 27, 2020"
        }
        
    
  
    
        ,"post14": {
            "title": "COVID-19 Growth Rate Prediction",
            "content": ". Note: This dashboard contains the results of a predictive model. This analysis is provided for informational purposes only. . Data . These are the countries included in the model: . &#34;Afghanistan, Albania, Algeria, Andorra, Argentina, Armenia, Australia (total), Austria, Azerbaijan, Bahrain, Belarus, Belgium, Bosnia and Herzegovina, Brazil, Brunei, Bulgaria, Burkina Faso, Cambodia, Cameroon, Canada (total), Chile, Colombia, Costa Rica, Cote d&#39;Ivoire, Croatia, Cuba, Cyprus, Czechia, Denmark, Denmark (total), Diamond Princess, Dominican Republic, Ecuador, Egypt, Estonia, Finland, France, France (total), Georgia, Germany, Ghana, Greece, Honduras, Hong Kong, Hungary, Iceland, India, Indonesia, Iran, Iraq, Ireland, Israel, Italy, Japan, Jordan, Kazakhstan, Korea, South, Kuwait, Latvia, Lebanon, Lithuania, Luxembourg, Malaysia, Malta, Mauritius, Mexico, Moldova, Morocco, Netherlands, New Zealand, Nigeria, North Macedonia, Norway, Oman, Pakistan, Panama, Peru, Philippines, Poland, Portugal, Qatar, Romania, Russia, San Marino, Saudi Arabia, Senegal, Serbia, Singapore, Slovakia, Slovenia, South Africa, Spain, Sri Lanka, Sweden, Switzerland, Taiwan*, Thailand, Tunisia, Turkey, US, Ukraine, United Arab Emirates, United Kingdom, United Kingdom (total), Uruguay, Uzbekistan, Venezuela, Vietnam, West Bank and Gaza&#34; . Predicted Cases By Country . Select a country from the drop down list below to toggle the visualization. . Growth Rate Predictions . Text(0.5, 0.98, &#39;Posterior of daily growth&#39;) . Model Diagnostics - Trace Plots . The following trace plots help to assess the convergence of the MCMC sampler. You can safely ignore this if not familiar with MCMC. . About This Analysis . The model that we are building assumes exponential growth. This is definitely wrong because growth would just continue uninterrupted into the future. However, in the early phase of an epidemic it&#39;s a reasonable assumption.1 . We assume a negative binomial likelihood as we are dealing with count data. A Poisson could also be used but the negative binomial allows us to also model the variance separately to give more flexibility. . The model is also hierarchical, pooling information from individual countries. . . This notebook gets up-to-date data from the &quot;2019 Novel Coronavirus COVID-19 (2019-nCoV) Data Repository by Johns Hopkins CSSE&quot; GitHub repository. This code is provided under the BSD-3 License. Link to original notebook.&#8617; . |",
            "url": "https://bielsnor.github.io/futureproof/growth-bayes/",
            "relUrl": "/growth-bayes/",
            "date": " • Mar 16, 2020"
        }
        
    
  

  
  

  

  
  

  
  

  
  

  
  

}